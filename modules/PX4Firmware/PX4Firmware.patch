diff --git a/Makefile b/Makefile
index 0075022..081e912 100644
--- a/Makefile
+++ b/Makefile
@@ -144,7 +144,7 @@ $(FIRMWARES): $(BUILD_DIR)%.build/firmware.px4:	generateuorbtopicheaders checksu
 	@$(ECHO) %%%% Building $(config) in $(work_dir)
 	@$(ECHO) %%%%
 	$(Q) $(MKDIR) -p $(work_dir)
-	$(Q) $(MAKE) -r -C $(work_dir) \
+	$(Q)+ $(MAKE) -r -C $(work_dir) \
 		-f $(PX4_MK_DIR)firmware.mk \
 		CONFIG=$(config) \
 		WORK_DIR=$(work_dir) \
@@ -161,7 +161,7 @@ define FMU_DEP
 $(BUILD_DIR)$(1).build/firmware.px4: $(IMAGE_DIR)px4io-$(call FMU_VERSION,$(1))_default.px4
 endef
 FMU_CONFIGS		:= $(filter px4fmu%,$(CONFIGS))
-$(foreach config,$(FMU_CONFIGS),$(eval $(call FMU_DEP,$(config))))
+# $(foreach config,$(FMU_CONFIGS),$(eval $(call FMU_DEP,$(config))))
 
 #
 # Build the NuttX export archives.
@@ -178,24 +178,16 @@ NUTTX_ARCHIVES		 = $(foreach board,$(BOARDS),$(ARCHIVE_DIR)$(board).export)
 .PHONY:			archives
 archives:		checksubmodules $(NUTTX_ARCHIVES)
 
-# We cannot build these parallel; note that we also force -j1 for the
-# sub-make invocations.
-ifneq ($(filter archives,$(MAKECMDGOALS)),)
-.NOTPARALLEL:
-endif
-
-J?=1
-
 $(ARCHIVE_DIR)%.export:	board = $(notdir $(basename $@))
 $(ARCHIVE_DIR)%.export:	configuration = nsh
 $(NUTTX_ARCHIVES): $(ARCHIVE_DIR)%.export: $(NUTTX_SRC)
 	@$(ECHO) %% Configuring NuttX for $(board)
 	$(Q) (cd $(NUTTX_SRC) && $(RMDIR) nuttx-export)
-	$(Q) $(MAKE) -r -j$(J) -C $(NUTTX_SRC) -r $(MQUIET) distclean
+	$(Q)+ $(MAKE) -C $(NUTTX_SRC) -r $(MQUIET) distclean
 	$(Q) (cd $(NUTTX_SRC)/configs && $(COPYDIR) $(PX4_BASE)nuttx-configs/$(board) .)
 	$(Q) (cd $(NUTTX_SRC)tools && ./configure.sh $(board)/$(configuration))
 	@$(ECHO) %% Exporting NuttX for $(board)
-	$(Q) $(MAKE) -r -j$(J) -C $(NUTTX_SRC) -r $(MQUIET) CONFIG_ARCH_BOARD=$(board) export
+	$(Q)+ $(MAKE) -C $(NUTTX_SRC) -r $(MQUIET) CONFIG_ARCH_BOARD=$(board) export
 	$(Q) $(MKDIR) -p $(dir $@)
 	$(Q) $(COPY) $(NUTTX_SRC)nuttx-export.zip $@
 	$(Q) (cd $(NUTTX_SRC)/configs && $(RMDIR) $(board))
@@ -212,11 +204,11 @@ BOARD			 = $(BOARDS)
 menuconfig: $(NUTTX_SRC)
 	@$(ECHO) %% Configuring NuttX for $(BOARD)
 	$(Q) (cd $(NUTTX_SRC) && $(RMDIR) nuttx-export)
-	$(Q) $(MAKE) -r -j$(J) -C $(NUTTX_SRC) -r $(MQUIET) distclean
+	$(Q)+ $(MAKE) -C $(NUTTX_SRC) -r $(MQUIET) distclean
 	$(Q) (cd $(NUTTX_SRC)/configs && $(COPYDIR) $(PX4_BASE)nuttx-configs/$(BOARD) .)
 	$(Q) (cd $(NUTTX_SRC)tools && ./configure.sh $(BOARD)/nsh)
 	@$(ECHO) %% Running menuconfig for $(BOARD)
-	$(Q) $(MAKE) -r -j$(J) -C $(NUTTX_SRC) -r $(MQUIET) menuconfig
+	$(Q)+ $(MAKE) -C $(NUTTX_SRC) -r $(MQUIET) menuconfig
 	@$(ECHO) %% Saving configuration file
 	$(Q)$(COPY) $(NUTTX_SRC).config $(PX4_BASE)nuttx-configs/$(BOARD)/nsh/defconfig
 else
@@ -272,10 +264,10 @@ generateuorbtopicheaders: checksubmodules
 		$(PX4_BASE)Tools/px_generate_uorb_topic_headers.py \
 		-d $(MSG_DIR) -o $(TOPICS_DIR) -e $(UORB_TEMPLATE_DIR) -t $(TOPICHEADER_TEMP_DIR))
 	@$(ECHO) "Generating multiplatform uORB topic wrapper headers"
+	$(Q) (rm -r $(TOPICHEADER_TEMP_DIR))
 	$(Q) (PYTHONPATH=$(GENMSG_PYTHONPATH):$(GENCPP_PYTHONPATH):$(PYTHONPATH) $(PYTHON) \
 		$(PX4_BASE)Tools/px_generate_uorb_topic_headers.py \
 		-d $(MSG_DIR) -o $(MULTIPLATFORM_HEADER_DIR) -e $(MULTIPLATFORM_TEMPLATE_DIR) -t $(TOPICHEADER_TEMP_DIR) -p $(MULTIPLATFORM_PREFIX))
-# clean up temporary files
 	$(Q) (rm -r $(TOPICHEADER_TEMP_DIR))
 
 #
@@ -287,7 +279,7 @@ testbuild:
 
 nuttx posix qurt: 
 ifeq ($(GOALS),)
-	make PX4_TARGET_OS=$@ $(GOALS)
+	+$(MAKE) PX4_TARGET_OS=$@ $(GOALS)
 else
 	export PX4_TARGET_OS=$@
 endif
@@ -296,7 +288,7 @@ posixrun:
 	Tools/posix_run.sh
 
 qurtrun:
-	make PX4_TARGET_OS=qurt sim
+	$(MAKE) PX4_TARGET_OS=qurt sim
 
 #
 # Unittest targets. Builds and runs the host-level
@@ -325,7 +317,7 @@ clean:
 distclean: clean
 	@echo > /dev/null
 	$(Q) $(REMOVE) $(ARCHIVE_DIR)*.export
-	$(Q) $(MAKE) -C $(NUTTX_SRC) -r $(MQUIET) distclean
+	$(Q)+ $(MAKE) -C $(NUTTX_SRC) -r $(MQUIET) distclean
 	$(Q) (cd $(NUTTX_SRC)/configs && $(FIND) . -maxdepth 1 -type l -delete)
 
 #
diff --git a/Tools/px_generate_uorb_topic_headers.py b/Tools/px_generate_uorb_topic_headers.py
index 75acd6a..7ed0b3a 100755
--- a/Tools/px_generate_uorb_topic_headers.py
+++ b/Tools/px_generate_uorb_topic_headers.py
@@ -43,6 +43,11 @@ import shutil
 import filecmp
 import argparse
 
+import sys
+px4_tools_dir = os.path.dirname(os.path.abspath(__file__))
+sys.path.append(px4_tools_dir + "/genmsg/src")
+sys.path.append(px4_tools_dir + "/gencpp/src")
+
 try:
         import genmsg.template_tools
 except ImportError as e:
@@ -79,7 +84,7 @@ def convert_file(filename, outputdir, templatedir, includepath):
         """
         Converts a single .msg file to a uorb header
         """
-        print("Generating headers from {0}".format(filename))
+        #print("Generating headers from {0}".format(filename))
         genmsg.template_tools.generate_from_file(filename,
                                                  package,
                                                  outputdir,
@@ -93,6 +98,30 @@ def convert_dir(inputdir, outputdir, templatedir):
         """
         Converts all .msg files in inputdir to uORB header files
         """
+
+        # Find the most recent modification time in input dir
+        maxinputtime = 0
+        for f in os.listdir(inputdir):
+                fni = os.path.join(inputdir, f)
+                if os.path.isfile(fni):
+                    it = os.path.getmtime(fni)
+                    if it > maxinputtime:
+                        maxinputtime = it;
+
+        # Find the most recent modification time in output dir
+        maxouttime = 0
+        if os.path.isdir(outputdir):
+            for f in os.listdir(outputdir):
+                    fni = os.path.join(outputdir, f)
+                    if os.path.isfile(fni):
+                        it = os.path.getmtime(fni)
+                        if it > maxouttime:
+                            maxouttime = it;
+
+        # Do not generate if nothing changed on the input
+        if (maxinputtime != 0 and maxouttime != 0 and maxinputtime < maxouttime):
+            return False
+
         includepath = incl_default + [':'.join([package, inputdir])]
         for f in os.listdir(inputdir):
                 # Ignore hidden files
@@ -109,8 +138,10 @@ def convert_dir(inputdir, outputdir, templatedir):
                              templatedir,
                              includepath)
 
+        return True
+
 
-def copy_changed(inputdir, outputdir, prefix=''):
+def copy_changed(inputdir, outputdir, prefix='', quiet=False):
         """
         Copies files from inputdir to outputdir if they don't exist in
         ouputdir or if their content changed
@@ -127,28 +158,32 @@ def copy_changed(inputdir, outputdir, prefix=''):
                         fno = os.path.join(outputdir, prefix + f)
                         if not os.path.isfile(fno):
                                 shutil.copy(fni, fno)
-                                print("{0}: new header file".format(f))
-                                continue
-                        # The file exists in inputdir and outputdir
-                        # only copy if contents do not match
-                        if not filecmp.cmp(fni, fno):
-                                shutil.copy(fni, fno)
-                                print("{0}: updated".format(f))
+                                if not quiet:
+                                    print("{0}: new header file".format(f))
                                 continue
 
-                        print("{0}: unchanged".format(f))
+                        if os.path.getmtime(fni) > os.path.getmtime(fno):
+                                # The file exists in inputdir and outputdir
+                                # only copy if contents do not match
+                                if not filecmp.cmp(fni, fno):
+                                        shutil.copy(fni, fno)
+                                        if not quiet:
+                                            print("{0}: updated".format(f))
+                                        continue
+
+                        if not quiet:
+                            print("{0}: unchanged".format(f))
 
 
-def convert_dir_save(inputdir, outputdir, templatedir, temporarydir, prefix):
+def convert_dir_save(inputdir, outputdir, templatedir, temporarydir, prefix, quiet=False):
         """
         Converts all .msg files in inputdir to uORB header files
         Unchanged existing files are not overwritten.
         """
         # Create new headers in temporary output directory
         convert_dir(inputdir, temporarydir, templatedir)
-
         # Copy changed headers from temporary dir to output dir
-        copy_changed(temporarydir, outputdir, prefix)
+        copy_changed(temporarydir, outputdir, prefix, quiet)
 
 if __name__ == "__main__":
         parser = argparse.ArgumentParser(
@@ -166,6 +201,9 @@ if __name__ == "__main__":
         parser.add_argument('-p', dest='prefix', default='',
                             help='string added as prefix to the output file '
                             ' name when converting directories')
+        parser.add_argument('-q', dest='quiet', default=False, action='store_true',
+                            help='string added as prefix to the output file '
+                            ' name when converting directories')
         args = parser.parse_args()
 
         if args.file is not None:
@@ -181,4 +219,5 @@ if __name__ == "__main__":
                     args.outputdir,
                     args.templatedir,
                     args.temporarydir,
-                    args.prefix)
+                    args.prefix,
+                    args.quiet)
diff --git a/makefiles/firmware_nuttx.mk b/makefiles/firmware_nuttx.mk
index 77bb2ba..b4b7d32 100644
--- a/makefiles/firmware_nuttx.mk
+++ b/makefiles/firmware_nuttx.mk
@@ -76,7 +76,7 @@ $(FIRMWARES): $(BUILD_DIR)%.build/firmware.px4:	generateuorbtopicheaders checksu
 #
 FMU_VERSION		 = $(patsubst px4fmu-%,%,$(word 1, $(subst _, ,$(1))))
 define FMU_DEP
-$(BUILD_DIR)$(1).build/firmware.px4: $(IMAGE_DIR)px4io-$(call FMU_VERSION,$(1))_default.px4
+#$(BUILD_DIR)$(1).build/firmware.px4: $(IMAGE_DIR)px4io-$(call FMU_VERSION,$(1))_default.px4
 endef
 FMU_CONFIGS		:= $(filter px4fmu%,$(CONFIGS))
 $(foreach config,$(FMU_CONFIGS),$(eval $(call FMU_DEP,$(config))))
diff --git a/makefiles/nuttx.mk b/makefiles/nuttx.mk
index 4ca1dc2..7c3b6a4 100644
--- a/makefiles/nuttx.mk
+++ b/makefiles/nuttx.mk
@@ -71,9 +71,10 @@ INCLUDE_DIRS		+= $(NUTTX_EXPORT_DIR)include \
 			   $(NUTTX_EXPORT_DIR)arch/common
 
 LIB_DIRS		+= $(NUTTX_EXPORT_DIR)libs
-LIBS			+= -lapps -lnuttx
+LIBS			+= -lapps -lnuttx -lconfigs
 NUTTX_LIBS		 = $(NUTTX_EXPORT_DIR)libs/libapps.a \
-			   $(NUTTX_EXPORT_DIR)libs/libnuttx.a
+			   $(NUTTX_EXPORT_DIR)libs/libnuttx.a \
+			   $(NUTTX_EXPORT_DIR)libs/libconfigs.a
 LINK_DEPS		+= $(NUTTX_LIBS)
 
 $(NUTTX_CONFIG_HEADER):	$(NUTTX_ARCHIVE)
diff --git a/makefiles/toolchain_gnu-arm-eabi.mk b/makefiles/toolchain_gnu-arm-eabi.mk
index 6c4e64f..1bbae2a 100644
--- a/makefiles/toolchain_gnu-arm-eabi.mk
+++ b/makefiles/toolchain_gnu-arm-eabi.mk
@@ -64,6 +64,9 @@ MAXOPTIMIZATION		 ?= -O3
 
 # Base CPU flags for each of the supported architectures.
 #
+ARCHCPUFLAGS_CORTEXM7	 = -mcpu=cortex-m7 \
+			   -mthumb \
+			   -mfloat-abi=soft
 ARCHCPUFLAGS_CORTEXM4F	 = -mcpu=cortex-m4 \
 			   -mthumb \
 			   -march=armv7e-m \
diff --git a/msg/actuator_armed.msg b/msg/actuator_armed.msg
index c809872..f307e36 100644
--- a/msg/actuator_armed.msg
+++ b/msg/actuator_armed.msg
@@ -1,6 +1,7 @@
 
 uint64 timestamp	# Microseconds since system boot
 bool armed		# Set to true if system is armed
+bool prearmed		# Set to true if the actuator safety is disabled but motors are not armed
 bool ready_to_arm	# Set to true if system is ready to be armed
 bool lockdown		# Set to true if actuators are forced to being disabled (due to emergency or HIL)
 bool force_failsafe	# Set to true if the actuators are forced to the failsafe position
diff --git a/msg/actuator_controls.msg b/msg/actuator_controls.msg
index 414eb06..a802f15 100644
--- a/msg/actuator_controls.msg
+++ b/msg/actuator_controls.msg
@@ -1,5 +1,15 @@
 uint8 NUM_ACTUATOR_CONTROLS = 8
 uint8 NUM_ACTUATOR_CONTROL_GROUPS = 4
+uint8 INDEX_ROLL = 0
+uint8 INDEX_PITCH = 1
+uint8 INDEX_YAW = 2
+uint8 INDEX_THROTTLE = 3
+uint8 INDEX_FLAPS = 4
+uint8 INDEX_SPOILERS = 5
+uint8 INDEX_AIRBRAKES = 6
+uint8 INDEX_LANDING_GEAR = 7
+uint8 GROUP_INDEX_ATTITUDE = 0
+uint8 GROUP_INDEX_ATTITUDE_ALTERNATE = 1
 uint64 timestamp
 uint64 timestamp_sample	    # the timestamp the data this control response is based on was sampled
 float32[8] control
diff --git a/msg/airspeed.msg b/msg/airspeed.msg
index 8d6af21..f0a109a 100644
--- a/msg/airspeed.msg
+++ b/msg/airspeed.msg
@@ -1,4 +1,6 @@
 uint64 timestamp			# microseconds since system boot, needed to integrate
 float32 indicated_airspeed_m_s		# indicated airspeed in meters per second, -1 if unknown
-float32 true_airspeed_m_s		# true airspeed in meters per second, -1 if unknown
+float32 true_airspeed_m_s		# true filtered airspeed in meters per second, -1 if unknown
+float32 true_airspeed_unfiltered_m_s	# true airspeed in meters per second, -1 if unknown
 float32 air_temperature_celsius		# air temperature in degrees celsius, -1000 if unknown
+float32 confidence			# confidence value from 0 to 1 for this sensor
diff --git a/msg/battery_status.msg b/msg/battery_status.msg
index 4ed56dd..75b144c 100644
--- a/msg/battery_status.msg
+++ b/msg/battery_status.msg
@@ -3,3 +3,4 @@ float32 voltage_v		# Battery voltage in volts, 0 if unknown
 float32 voltage_filtered_v	# Battery voltage in volts, filtered, 0 if unknown
 float32 current_a		# Battery current in amperes, -1 if unknown
 float32 discharged_mah		# Discharged amount in mAh, -1 if unknown
+bool is_powering_off		# Power off event imminent indication, false if unknown
diff --git a/msg/estimator_status.msg b/msg/estimator_status.msg
index 92e5303..6bbcd59 100644
--- a/msg/estimator_status.msg
+++ b/msg/estimator_status.msg
@@ -1,6 +1,19 @@
 uint64 timestamp		# Timestamp in microseconds since boot
 float32[32] states		# Internal filter states
 float32 n_states		# Number of states effectively used
+float32[3] vibe			# Vibration levels in X, Y and Z
 uint8 nan_flags			# Bitmask to indicate NaN states
 uint8 health_flags		# Bitmask to indicate sensor health states (vel, pos, hgt)
 uint8 timeout_flags		# Bitmask to indicate timeout flags (vel, pos, hgt)
+float32[28] covariances	# Diagonal Elements of Covariance Matrix
+uint16 gps_check_fail_flags     # Bitmask to indicate status of GPS checks - see definition below
+# bits are true when corresponding test has failed
+# 0 : minimum required sat count fail
+# 1 : minimum required GDoP fail
+# 2 : maximum allowed horizontal position error fail
+# 3 : maximum allowed vertical position error fail
+# 4 : maximum allowed speed error fail
+# 5 : maximum allowed horizontal position drift fail
+# 6 : maximum allowed vertical position drift fail
+# 7 : maximum allowed horizontal speed fail
+# 8 : maximum allowed vertical velocity discrepancy fail
diff --git a/msg/fw_virtual_rates_setpoint.msg b/msg/fw_virtual_rates_setpoint.msg
index 834113c..4fa09b5 100644
--- a/msg/fw_virtual_rates_setpoint.msg
+++ b/msg/fw_virtual_rates_setpoint.msg
@@ -1,6 +1,16 @@
+###############################################################################################
+# The vehicle_rates_setpoint.msg needs to be in sync with the virtual setpoint messages
+#
+# Please keep the following messages identical;
+#	vehicle_rates_setpoint.msg
+#	mc_virtual_rates_setpoint.msg
+#	fw_virtual_rates_setpoint.msg
+#
+###############################################################################################
+
 uint64 timestamp    # in microseconds since system start
 
 float32 roll	    # body angular rates in NED frame
 float32 pitch	    # body angular rates in NED frame
-float32 yaw	    # body angular rates in NED frame
+float32 yaw			# body angular rates in NED frame
 float32 thrust	    # thrust normalized to 0..1
diff --git a/msg/geofence_result.msg b/msg/geofence_result.msg
index 7fc21c2..165d92b 100644
--- a/msg/geofence_result.msg
+++ b/msg/geofence_result.msg
@@ -1 +1,8 @@
+uint8 GF_ACTION_NONE = 0                    # no action on geofence violation
+uint8 GF_ACTION_WARN = 1                    # critical mavlink message
+uint8 GF_ACTION_LOITER = 2                  # switch to AUTO|LOITER
+uint8 GF_ACTION_RTL = 3                     # switch to AUTO|RTL
+uint8 GF_ACTION_TERMINATE = 4               # flight termination
+
 bool geofence_violated		# true if the geofence is violated
+uint8 geofence_action       # action to take when geofence is violated
\ No newline at end of file
diff --git a/msg/home_position.msg b/msg/home_position.msg
index d8aff3f..7135c07 100644
--- a/msg/home_position.msg
+++ b/msg/home_position.msg
@@ -8,3 +8,8 @@ float32 alt				# Altitude in meters (AMSL)
 float32 x				# X coordinate in meters
 float32 y				# Y coordinate in meters
 float32 z				# Z coordinate in meters
+
+float32 yaw				# Yaw angle in radians
+float32 direction_x		# Takeoff direction in NED X
+float32 direction_y		# Takeoff direction in NED Y
+float32 direction_z		# Takeoff direction in NED Z
diff --git a/msg/manual_control_setpoint.msg b/msg/manual_control_setpoint.msg
index d3cfb07..81d7763 100644
--- a/msg/manual_control_setpoint.msg
+++ b/msg/manual_control_setpoint.msg
@@ -3,6 +3,15 @@ uint8 SWITCH_POS_NONE = 0		# switch is not mapped
 uint8 SWITCH_POS_ON = 1			# switch activated (value = 1)
 uint8 SWITCH_POS_MIDDLE = 2		# middle position (value = 0)
 uint8 SWITCH_POS_OFF = 3		# switch not activated (value = -1)
+int8 MODE_SLOT_NONE = -1		# no mode slot assigned
+int8 MODE_SLOT_1 = 0			# mode slot 1 selected
+int8 MODE_SLOT_2 = 1			# mode slot 2 selected
+int8 MODE_SLOT_3 = 2			# mode slot 3 selected
+int8 MODE_SLOT_4 = 3			# mode slot 4 selected
+int8 MODE_SLOT_5 = 4			# mode slot 5 selected
+int8 MODE_SLOT_6 = 5			# mode slot 6 selected
+int8 MODE_SLOT_MAX = 6			# number of slots plus one
+
 uint64 timestamp
 
 # Any of the channels may not be available and be set to NaN
@@ -26,7 +35,7 @@ float32 z			 # throttle stick position 0..1
 				 # in general the value corresponds to the demanded throttle by the user,
 				 # if the input is used for setting the setpoint of a vertical position
 				 # controller any value > 0.5 means up and any value < 0.5 means down
-float32 r			 # yaw stick/twist positon, -1..1
+float32 r			 # yaw stick/twist position, -1..1
 				 # in general corresponds to the righthand rotation around the vertical
 				 # (downwards) axis of the vehicle
 float32 flaps			 # flap position
@@ -38,7 +47,10 @@ float32 aux5			 # default function: payload drop
 
 uint8 mode_switch		 # main mode 3 position switch (mandatory): _MANUAL_, ASSIST, AUTO
 uint8 return_switch		 # return to launch 2 position switch (mandatory): _NORMAL_, RTL
+uint8 rattitude_switch	 # rattitude control 2 position switch (optional): _MANUAL, RATTITUDE
 uint8 posctl_switch		 # position control 2 position switch (optional): _ALTCTL_, POSCTL
 uint8 loiter_switch		 # loiter 2 position switch (optional): _MISSION_, LOITER
 uint8 acro_switch		 # acro 2 position switch (optional): _MANUAL_, ACRO
-uint8 offboard_switch		 # offboard 2 position switch (optional): _NORMAL_, OFFBOARD
+uint8 offboard_switch	 # offboard 2 position switch (optional): _NORMAL_, OFFBOARD
+uint8 kill_switch		 # throttle kill: _NORMAL_, KILL
+int8 mode_slot			 # the slot a specific model selector is in
diff --git a/msg/mc_virtual_rates_setpoint.msg b/msg/mc_virtual_rates_setpoint.msg
index 834113c..4fa09b5 100644
--- a/msg/mc_virtual_rates_setpoint.msg
+++ b/msg/mc_virtual_rates_setpoint.msg
@@ -1,6 +1,16 @@
+###############################################################################################
+# The vehicle_rates_setpoint.msg needs to be in sync with the virtual setpoint messages
+#
+# Please keep the following messages identical;
+#	vehicle_rates_setpoint.msg
+#	mc_virtual_rates_setpoint.msg
+#	fw_virtual_rates_setpoint.msg
+#
+###############################################################################################
+
 uint64 timestamp    # in microseconds since system start
 
 float32 roll	    # body angular rates in NED frame
 float32 pitch	    # body angular rates in NED frame
-float32 yaw	    # body angular rates in NED frame
+float32 yaw			# body angular rates in NED frame
 float32 thrust	    # thrust normalized to 0..1
diff --git a/msg/parameter_update.msg b/msg/parameter_update.msg
index 39dc336..78cebf7 100644
--- a/msg/parameter_update.msg
+++ b/msg/parameter_update.msg
@@ -1 +1,2 @@
 uint64 timestamp	# time at which the latest parameter was updated
+bool saved		# wether the change has already been saved to disk
diff --git a/msg/position_setpoint.msg b/msg/position_setpoint.msg
index ae6756a..3948859 100644
--- a/msg/position_setpoint.msg
+++ b/msg/position_setpoint.msg
@@ -7,6 +7,7 @@ uint8 SETPOINT_TYPE_TAKEOFF=3	# takeoff setpoint
 uint8 SETPOINT_TYPE_LAND=4	# land setpoint, altitude must be ignored, descend until landing
 uint8 SETPOINT_TYPE_IDLE=5	# do nothing, switch off motors or keep at idle speed (MC)
 uint8 SETPOINT_TYPE_OFFBOARD=6 	# setpoint in NED frame (x, y, z, vx, vy, vz) set by offboard
+uint8 SETPOINT_TYPE_FOLLOW_TARGET=7  # setpoint in NED frame (x, y, z, vx, vy, vz) set by follow target
 
 bool valid			# true if setpoint is valid
 uint8 type			# setpoint type to adjust behavior of position controller
@@ -23,6 +24,7 @@ float64 lon			# longitude, in deg
 float32 alt			# altitude AMSL, in m
 float32 yaw			# yaw (only for multirotors), in rad [-PI..PI), NaN = hold current yaw
 bool yaw_valid			# true if yaw setpoint valid
+bool disable_mc_yaw_control		# control yaw for mc (used for vtol weather-vane mode)
 float32 yawspeed		# yawspeed (only for multirotors, in rad/s)
 bool yawspeed_valid		# true if yawspeed setpoint valid
 float32 loiter_radius		# loiter radius (only for fixed wing), in m
@@ -33,3 +35,5 @@ float32 a_y			# acceleration y setpoint
 float32 a_z			# acceleration z setpoint
 bool acceleration_valid		# true if acceleration setpoint is valid/should be used
 bool acceleration_is_force	# interprete acceleration as force
+float32 acceptance_radius   # navigation acceptance_radius if we're doing waypoint navigation
+float32 cruising_speed		# the generally desired cruising speed (not a hard constraint)
diff --git a/msg/rc_channels.msg b/msg/rc_channels.msg
index 0fa5ed2..3171fbc 100644
--- a/msg/rc_channels.msg
+++ b/msg/rc_channels.msg
@@ -1,4 +1,4 @@
-int32 RC_CHANNELS_FUNCTION_MAX=19
+int32 RC_CHANNELS_FUNCTION_MAX=21
 uint8 RC_CHANNELS_FUNCTION_THROTTLE=0
 uint8 RC_CHANNELS_FUNCTION_ROLL=1
 uint8 RC_CHANNELS_FUNCTION_PITCH=2
@@ -18,10 +18,13 @@ uint8 RC_CHANNELS_FUNCTION_AUX_5=15
 uint8 RC_CHANNELS_FUNCTION_PARAM_1=16
 uint8 RC_CHANNELS_FUNCTION_PARAM_2=17
 uint8 RC_CHANNELS_FUNCTION_PARAM_3_5=18
+uint8 RC_CHANNELS_FUNCTION_RATTITUDE=19
+uint8 RC_CHANNELS_FUNCTION_KILLSWITCH=20
 uint64 timestamp						# Timestamp in microseconds since boot time
 uint64 timestamp_last_valid					# Timestamp of last valid RC signal
-float32[19] channels						# Scaled to -1..1 (throttle: 0..1)
+float32[18] channels						# Scaled to -1..1 (throttle: 0..1)
 uint8 channel_count						# Number of valid channels
-int8[19] function						# Functions mapping
+int8[21] function						# Functions mapping
 uint8 rssi							# Receive signal strength index
 bool signal_lost						# Control signal lost, should be checked together with topic timeout
+uint32 frame_drop_count						# Number of dropped frames
diff --git a/msg/sensor_combined.msg b/msg/sensor_combined.msg
index c5e427e..ec58e6f 100644
--- a/msg/sensor_combined.msg
+++ b/msg/sensor_combined.msg
@@ -4,6 +4,14 @@ int32 MAGNETOMETER_MODE_NORMAL = 0
 int32 MAGNETOMETER_MODE_POSITIVE_BIAS = 1
 int32 MAGNETOMETER_MODE_NEGATIVE_BIAS = 2
 
+uint32 SENSOR_PRIO_MIN = 0
+uint32 SENSOR_PRIO_VERY_LOW = 25
+uint32 SENSOR_PRIO_LOW = 50
+uint32 SENSOR_PRIO_DEFAULT = 75
+uint32 SENSOR_PRIO_HIGH = 100
+uint32 SENSOR_PRIO_VERY_HIGH = 125
+uint32 SENSOR_PRIO_MAX = 255
+
 # Sensor readings in raw and SI-unit form.
 #
 # These values are read from the sensors. Raw values are in sensor-specific units,
@@ -18,83 +26,49 @@ int32 MAGNETOMETER_MODE_NEGATIVE_BIAS = 2
 # NOTE: Ordering of fields optimized to align to 32 bit / 4 bytes Change with consideration only
 
 uint64 timestamp			# Timestamp in microseconds since boot, from gyro
-#
-int16[3] gyro_raw			# Raw sensor values of angular velocity
-float32[3] gyro_rad_s			# Angular velocity in radian per seconds
-uint32 gyro_errcount			# Error counter for gyro 0
-float32 gyro_temp			# Temperature of gyro 0
-
-int16[3] accelerometer_raw		# Raw acceleration in NED body frame
-float32[3] accelerometer_m_s2		# Acceleration in NED body frame, in m/s^2
-int16 accelerometer_mode			# Accelerometer measurement mode
-float32 accelerometer_range_m_s2		# Accelerometer measurement range in m/s^2
-uint64 accelerometer_timestamp	# Accelerometer timestamp
-uint32 accelerometer_errcount	# Error counter for accel 0
-float32 accelerometer_temp		# Temperature of accel 0
-
-int16[3] magnetometer_raw		# Raw magnetic field in NED body frame
-float32[3] magnetometer_ga		# Magnetic field in NED body frame, in Gauss
-int16 magnetometer_mode			# Magnetometer measurement mode
-float32 magnetometer_range_ga		# measurement range in Gauss
-float32 magnetometer_cuttoff_freq_hz	# Internal analog low pass frequency of sensor
-uint64 magnetometer_timestamp	# Magnetometer timestamp
-uint32 magnetometer_errcount		# Error counter for mag 0
-float32 magnetometer_temp		# Temperature of mag 0
-
-int16[3] gyro1_raw			# Raw sensor values of angular velocity
-float32[3] gyro1_rad_s			# Angular velocity in radian per seconds
-uint64 gyro1_timestamp		# Gyro timestamp
-uint32 gyro1_errcount		# Error counter for gyro 1
-float32 gyro1_temp			# Temperature of gyro 1
-
-int16[3] accelerometer1_raw		# Raw acceleration in NED body frame
-float32[3] accelerometer1_m_s2		# Acceleration in NED body frame, in m/s^2
-uint64 accelerometer1_timestamp	# Accelerometer timestamp
-uint32 accelerometer1_errcount	# Error counter for accel 1
-float32 accelerometer1_temp		# Temperature of accel 1
-
-int16[3] magnetometer1_raw		# Raw magnetic field in NED body frame
-float32[3] magnetometer1_ga		# Magnetic field in NED body frame, in Gauss
-uint64 magnetometer1_timestamp	# Magnetometer timestamp
-uint32 magnetometer1_errcount	# Error counter for mag 1
-float32 magnetometer1_temp		# Temperature of mag 1
-
-int16[3] gyro2_raw			# Raw sensor values of angular velocity
-float32[3] gyro2_rad_s			# Angular velocity in radian per seconds
-uint64 gyro2_timestamp		# Gyro timestamp
-uint32 gyro2_errcount		# Error counter for gyro 1
-float32 gyro2_temp			# Temperature of gyro 1
-
-int16[3] accelerometer2_raw		# Raw acceleration in NED body frame
-float32[3] accelerometer2_m_s2		# Acceleration in NED body frame, in m/s^2
-uint64 accelerometer2_timestamp	# Accelerometer timestamp
-uint32 accelerometer2_errcount	# Error counter for accel 2
-float32 accelerometer2_temp		# Temperature of accel 2
-
-int16[3] magnetometer2_raw		# Raw magnetic field in NED body frame
-float32[3] magnetometer2_ga		# Magnetic field in NED body frame, in Gauss
-uint64 magnetometer2_timestamp	# Magnetometer timestamp
-uint32 magnetometer2_errcount	# Error counter for mag 2
-float32 magnetometer2_temp		# Temperature of mag 2
-
-float32 baro_pres_mbar			# Barometric pressure, already temp. comp.
-float32 baro_alt_meter			# Altitude, already temp. comp.
-float32 baro_temp_celcius		# Temperature in degrees celsius
-uint64 baro_timestamp		# Barometer timestamp
-
-float32 baro1_pres_mbar			# Barometric pressure, already temp. comp.
-float32 baro1_alt_meter			# Altitude, already temp. comp.
-float32 baro1_temp_celcius		# Temperature in degrees celsius
-uint64 baro1_timestamp		# Barometer timestamp
+uint64[3] gyro_timestamp			# Gyro timestamps
+int16[9] gyro_raw			# Raw sensor values of angular velocity
+float32[9] gyro_rad_s			# Angular velocity in radian per seconds
+uint32[3] gyro_priority			# Sensor priority
+float32[9] gyro_integral_rad		# delta angle in radians
+uint64[3] gyro_integral_dt			# delta time for gyro integral in us
+uint32[3] gyro_errcount			# Error counter for gyro 0
+float32[3] gyro_temp			# Temperature of gyro 0
+
+int16[9] accelerometer_raw		# Raw acceleration in NED body frame
+float32[9] accelerometer_m_s2		# Acceleration in NED body frame, in m/s^2
+float32[9] accelerometer_integral_m_s		# velocity in NED body frame, in m/s^2
+uint64[3] accelerometer_integral_dt		# delta time for accel integral in us
+int16[3] accelerometer_mode			# Accelerometer measurement mode
+float32[3] accelerometer_range_m_s2		# Accelerometer measurement range in m/s^2
+uint64[3] accelerometer_timestamp	# Accelerometer timestamp
+uint32[3] accelerometer_priority	# Sensor priority
+uint32[3] accelerometer_errcount	# Error counter for accel 0
+float32[3] accelerometer_temp		# Temperature of accel 0
+
+int16[9] magnetometer_raw		# Raw magnetic field in NED body frame
+float32[9] magnetometer_ga		# Magnetic field in NED body frame, in Gauss
+int16[3] magnetometer_mode			# Magnetometer measurement mode
+float32[3] magnetometer_range_ga		# measurement range in Gauss
+float32[3] magnetometer_cuttoff_freq_hz	# Internal analog low pass frequency of sensor
+uint64[3] magnetometer_timestamp	# Magnetometer timestamp
+uint32[3] magnetometer_priority			# Sensor priority
+uint32[3] magnetometer_errcount		# Error counter for mag 0
+float32[3] magnetometer_temp		# Temperature of mag 0
+
+float32[3] baro_pres_mbar			# Barometric pressure, already temp. comp.
+float32[3] baro_alt_meter			# Altitude, already temp. comp.
+float32[3] baro_temp_celcius		# Temperature in degrees celsius
+uint64[3] baro_timestamp		# Barometer timestamp
+uint32[3] baro_priority			# Sensor priority
+uint32[3] baro_errcount			# Error count in communication
 
 float32[10] adc_voltage_v		# ADC voltages of ADC Chan 10/11/12/13 or -1
 uint16[10] adc_mapping		# Channel indices of each of these values
 float32 mcu_temp_celcius			# Internal temperature measurement of MCU
 
-float32 differential_pressure_pa			# Airspeed sensor differential pressure
-uint64 differential_pressure_timestamp	# Last measurement timestamp
-float32 differential_pressure_filtered_pa	# Low pass filtered airspeed sensor differential pressure reading
-
-float32 differential_pressure1_pa			# Airspeed sensor differential pressure
-uint64 differential_pressure1_timestamp	# Last measurement timestamp
-float32 differential_pressure1_filtered_pa	# Low pass filtered airspeed sensor differential pressure reading
+float32[3] differential_pressure_pa			# Airspeed sensor differential pressure
+uint64[3] differential_pressure_timestamp	# Last measurement timestamp
+float32[3] differential_pressure_filtered_pa	# Low pass filtered airspeed sensor differential pressure reading
+uint32[3] differential_pressure_priority			# Sensor priority
+uint32[3] differential_pressure_errcount			# Error count in communication
diff --git a/msg/tecs_status.msg b/msg/tecs_status.msg
index ccac921..4dcd16b 100644
--- a/msg/tecs_status.msg
+++ b/msg/tecs_status.msg
@@ -18,9 +18,12 @@ float32 airspeed_filtered
 float32 airspeedDerivativeSp
 float32 airspeedDerivative
 
-float32 totalEnergyRateSp
-float32 totalEnergyRate
-float32 energyDistributionRateSp
-float32 energyDistributionRate
+float32 totalEnergyError
+float32 energyDistributionError
+float32 totalEnergyRateError
+float32 energyDistributionRateError
+
+float32 throttle_integ
+float32 pitch_integ
 
 uint8 mode
diff --git a/msg/vehicle_attitude.msg b/msg/vehicle_attitude.msg
index 6387914..0ee90cd 100644
--- a/msg/vehicle_attitude.msg
+++ b/msg/vehicle_attitude.msg
@@ -10,6 +10,9 @@ float32 yawspeed	# Yaw body angular rate (rad/s, x forward/y right/z down)
 float32 rollacc		# Roll angular accelration (rad/s^2, x forward/y right/z down)
 float32 pitchacc	# Pitch angular acceleration (rad/s^2, x forward/y right/z down)
 float32 yawacc		# Yaw angular acceleration (rad/s^2, x forward/y right/z down)
+float32 rate_vibration	# Value between 0 and 1 indicating vibration. A value of 0 means no vibration, a value of 1 indicates unbearable vibration levels.
+float32 accel_vibration	# Value between 0 and 1 indicating vibration. A value of 0 means no vibration, a value of 1 indicates unbearable vibration levels.
+float32 mag_vibration	# Value between 0 and 1 indicating vibration. A value of 0 means no vibration, a value of 1 indicates unbearable vibration levels.
 float32[3] rate_offsets	# Offsets of the body angular rates from zero
 float32[9] R		# Rotation matrix, body to world, (Tait-Bryan, NED)
 float32[4] q		# Quaternion (NED)
diff --git a/msg/vehicle_attitude_setpoint.msg b/msg/vehicle_attitude_setpoint.msg
index 7bbb670..6c12b22 100644
--- a/msg/vehicle_attitude_setpoint.msg
+++ b/msg/vehicle_attitude_setpoint.msg
@@ -1,3 +1,12 @@
+###############################################################################################
+# The vehicle_attitude_setpoint.msg needs to be in sync with the virtual setpoint messages
+#
+# Please keep the following messages identical;
+#	vehicle_attitude_setpoint.msg
+#	mc_virtual_attitude_setpoint.msg
+#	fw_virtual_attitude_setpoint.msg
+#
+###############################################################################################
 
 uint64 timestamp				# in microseconds since system start, is set whenever the writing thread stores new data
 
@@ -21,3 +30,8 @@ float32 thrust					# Thrust in Newton the power system should generate
 bool roll_reset_integral			# Reset roll integral part (navigation logic change)
 bool pitch_reset_integral			# Reset pitch integral part (navigation logic change)
 bool yaw_reset_integral				# Reset yaw integral part (navigation logic change)
+
+bool fw_control_yaw					# control heading with rudder (used for auto takeoff on runway)
+bool disable_mc_yaw_control			# control yaw for mc (used for vtol weather-vane mode)
+
+bool apply_flaps
diff --git a/msg/vehicle_command.msg b/msg/vehicle_command.msg
index 391dc01..f310a01 100644
--- a/msg/vehicle_command.msg
+++ b/msg/vehicle_command.msg
@@ -11,6 +11,8 @@ uint32 VEHICLE_CMD_NAV_LAND = 21			# Land at location |Empty| Empty| Empty| Desi
 uint32 VEHICLE_CMD_NAV_TAKEOFF = 22			# Takeoff from ground / hand |Minimum pitch (if airspeed sensor present), desired pitch without sensor| Empty| Empty| Yaw angle (if magnetometer present), ignored without magnetometer| Latitude| Longitude| Altitude| 
 uint32 VEHICLE_CMD_NAV_ROI = 80				# Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. |Region of intereset mode. (see MAV_ROI enum)| MISSION index/ target ID. (see MAV_ROI enum)| ROI index (allows a vehicle to manage multiple ROI's)| Empty| x the location of the fixed ROI (see MAV_FRAME)| y| z| 
 uint32 VEHICLE_CMD_NAV_PATHPLANNING = 81		# Control autonomous path planning on the MAV. |0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning| 0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid| Empty| Yaw angle at goal, in compass degrees, [0..360]| Latitude/X of goal| Longitude/Y of goal| Altitude/Z of goal| 
+uint32 VEHICLE_CMD_NAV_VTOL_TAKEOFF = 84		# Takeoff from ground / hand and transition to fixed wing |Minimum pitch (if airspeed sensor present), desired pitch without sensor| Empty| Empty| Yaw angle (if magnetometer present), ignored without magnetometer| Latitude| Longitude| Altitude|
+uint32 VEHICLE_CMD_NAV_VTOL_LAND = 85			# Transition to MC and land at location |Empty| Empty| Empty| Desired yaw angle.| Latitude| Longitude| Altitude|
 uint32 VEHICLE_CMD_NAV_GUIDED_LIMITS = 90		# set limits for external control |timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout| absolute altitude min (in meters, AMSL) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit| absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit| horizontal move limit (in meters, AMSL) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit| Empty| Empty| Empty| 
 uint32 VEHICLE_CMD_NAV_GUIDED_MASTER = 91		# set id of master controller |System ID| Component ID| Empty| Empty| Empty| Empty| Empty| 
 uint32 VEHICLE_CMD_NAV_GUIDED_ENABLE = 92		# hand control over to an external controller |On / Off (> 0.5f on)| Empty| Empty| Empty| Empty| Empty| Empty| 
@@ -30,7 +32,10 @@ uint32 VEHICLE_CMD_DO_REPEAT_RELAY = 182		# Cycle a relay on and off for a desir
 uint32 VEHICLE_CMD_DO_SET_SERVO = 183			# Set a servo to a desired PWM value. |Servo number| PWM (microseconds, 1000 to 2000 typical)| Empty| Empty| Empty| Empty| Empty| 
 uint32 VEHICLE_CMD_DO_REPEAT_SERVO = 184		# Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period. |Servo number| PWM (microseconds, 1000 to 2000 typical)| Cycle count| Cycle time (seconds)| Empty| Empty| Empty| 
 uint32 VEHICLE_CMD_DO_FLIGHTTERMINATION=185		# Terminate flight immediately |Flight termination activated if > 0.5| Empty| Empty| Empty| Empty| Empty| Empty| 
+uint32 VEHICLE_CMD_DO_REPOSITION = 192
+uint32 VEHICLE_CMD_DO_PAUSE_CONTINUE = 193
 uint32 VEHICLE_CMD_DO_CONTROL_VIDEO = 200		# Control onboard camera system. |Camera ID (-1 for all)| Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw| Transmission mode: 0: video stream, >0: single images every n seconds (decimal)| Recording: 0: disabled, 1: enabled compressed, 2: enabled raw| Empty| Empty| Empty| 
+uint32 VEHICLE_CMD_DO_DIGICAM_CONTROL=203
 uint32 VEHICLE_CMD_DO_MOUNT_CONFIGURE=204		# Mission command to configure a camera or antenna mount |Mount operation mode (see MAV_MOUNT_MODE enum)| stabilize roll? (1 = yes, 0 = no)| stabilize pitch? (1 = yes, 0 = no)| stabilize yaw? (1 = yes, 0 = no)| Empty| Empty| Empty| 
 uint32 VEHICLE_CMD_DO_MOUNT_CONTROL=205			# Mission command to control a camera or antenna mount |pitch or lat in degrees, depending on mount mode.| roll or lon in degrees depending on mount mode| yaw or alt (in meters) depending on mount mode| reserved| reserved| reserved| MAV_MOUNT_MODE enum value| 
 uint32 VEHICLE_CMD_DO_SET_CAM_TRIGG_DIST=206		# Mission command to set CAM_TRIGG_DIST for this flight |Camera trigger distance (meters)| Empty| Empty| Empty| Empty| Empty| Empty| 
@@ -48,9 +53,12 @@ uint32 VEHICLE_CMD_PREFLIGHT_REBOOT_SHUTDOWN = 246	# Request the reboot or shutd
 uint32 VEHICLE_CMD_OVERRIDE_GOTO = 252			# Hold / continue the current action |MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan| MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position| MAV_FRAME coordinate frame of hold point| Desired yaw angle in degrees| Latitude / X position| Longitude / Y position| Altitude / Z position| 
 uint32 VEHICLE_CMD_MISSION_START = 300			# start running a mission |first_item: the first mission item to run| last_item:  the last mission item to run (after this item is run, the mission ends)| 
 uint32 VEHICLE_CMD_COMPONENT_ARM_DISARM = 400		# Arms / Disarms a component |1 to arm, 0 to disarm| 
-uint32 VEHICLE_CMD_START_RX_PAIR = 500			# Starts receiver pairing |0:Spektrum| 0:Spektrum DSM2, 1:Spektrum DSMX| 
+uint32 VEHICLE_CMD_START_RX_PAIR = 500			# Starts receiver pairing |0:Spektrum| 0:Spektrum DSM2, 1:Spektrum DSMX|
+uint32 VEHICLE_CMD_DO_TRIGGER_CONTROL = 2003            # Enable or disable on-board camera triggering system
+uint32 VEHICLE_CMD_DO_VTOL_TRANSITION = 3000    # Command VTOL transition
 uint32 VEHICLE_CMD_PAYLOAD_PREPARE_DEPLOY = 30001	# Prepare a payload deployment in the flight plan
 uint32 VEHICLE_CMD_PAYLOAD_CONTROL_DEPLOY = 30002	# Control a pre-programmed payload deployment
+uint32 VEHICLE_CMD_PREFLIGHT_UAVCAN = 243		# UAVCAN configuration. If param 1 == 1 actuator mapping and direction assignment should be started 
 
 uint32 VEHICLE_CMD_RESULT_ACCEPTED = 0			# Command ACCEPTED and EXECUTED |
 uint32 VEHICLE_CMD_RESULT_TEMPORARILY_REJECTED = 1	# Command TEMPORARY REJECTED/DENIED |
diff --git a/msg/vehicle_global_position.msg b/msg/vehicle_global_position.msg
index 6a38e2c..8aa7917 100644
--- a/msg/vehicle_global_position.msg
+++ b/msg/vehicle_global_position.msg
@@ -4,17 +4,18 @@
 # estimator, which will take more sources of information into account than just GPS,
 # e.g. control inputs of the vehicle in a Kalman-filter implementation.
 #
-uint64 timestamp		# Time of this estimate, in microseconds since system start
-uint64 time_utc_usec		# GPS UTC timestamp in microseconds
-float64 lat			# Latitude in degrees
-float64 lon			# Longitude in degrees
-float32 alt			# Altitude AMSL in meters
-float32 vel_n			# Ground north velocity, m/s
-float32 vel_e			# Ground east velocity, m/s
-float32 vel_d			# Ground downside velocity, m/s
-float32 yaw 			# Yaw in radians -PI..+PI.
-float32 eph			# Standard deviation of position estimate horizontally
-float32 epv			# Standard deviation of position vertically
-float32 terrain_alt		# Terrain altitude in m, WGS84
+uint64 timestamp		# Time of this estimate since system start, (microseconds)
+uint64 time_utc_usec		# GPS UTC timestamp, (microseconds)
+float64 lat			# Latitude, (degrees)
+float64 lon			# Longitude, (degrees)
+float32 alt			# Altitude AMSL, (meters)
+float32 vel_n			# North velocity in NED earth-fixed frame, (metres/sec)
+float32 vel_e			# East velocity in NED earth-fixed frame, (metres/sec)
+float32 vel_d			# Down velocity in NED earth-fixed frame, (metres/sec)
+float32 yaw 			# Euler yaw angle relative to NED earth-fixed frame, -PI..+PI, (radians)
+float32 eph			# Standard deviation of horizontal position error, (metres)
+float32 epv			# Standard deviation of vertical position error, (metres)
+float32 terrain_alt		# Terrain altitude WGS84, (metres)
 bool terrain_alt_valid		# Terrain altitude estimate is valid
 bool dead_reckoning		# True if this position is estimated through dead-reckoning
+float32 pressure_alt		# Pressure altitude AMSL, (metres)
diff --git a/msg/vehicle_gps_position.msg b/msg/vehicle_gps_position.msg
index 25c532c..ab8a928 100644
--- a/msg/vehicle_gps_position.msg
+++ b/msg/vehicle_gps_position.msg
@@ -1,29 +1,33 @@
 # GPS position in WGS84 coordinates.
-uint64 timestamp_position	# Timestamp for position information 
-int32 lat			# Latitude in 1E-7 degrees 
+uint64 timestamp_position	# Time of the position estimates since system start, (microseconds)
+int32 lat			# Latitude in 1E-7 degrees
 int32 lon			# Longitude in 1E-7 degrees 
-int32 alt			# Altitude in 1E-3 meters (millimeters) above MSL  
+int32 alt			# Altitude in 1E-3 meters above MSL, (millimetres)
+int32 alt_ellipsoid 		# Altitude in 1E-3 meters bove Ellipsoid, (millimetres)
 
-uint64 timestamp_variance
-float32 s_variance_m_s		# speed accuracy estimate m/s 
-float32 c_variance_rad		# course accuracy estimate rad 
+uint64 timestamp_variance	# Time of the accuracy estimates since system start, (microseconds)
+float32 s_variance_m_s		# GPS speed accuracy estimate, (metres/sec)
+float32 c_variance_rad		# GPS course accuracy estimate, (radians) 
 uint8 fix_type # 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: RTCM code differential, 5: Real-Time Kinematic, float, 6: Real-Time Kinematic, fixed, 8: Extrapolated. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.   
 
-float32 eph			# GPS HDOP horizontal dilution of position in m 
-float32 epv			# GPS VDOP horizontal dilution of position in m 
+float32 eph			# GPS horizontal position accuracy (metres)
+float32 epv			# GPS vertical position accuracy (metres)
+
+float32 hdop			# Horizontal dilution of precision
+float32 vdop			# Vertical dilution of precision
 
 int32 noise_per_ms		# GPS noise per millisecond
 int32 jamming_indicator		# indicates jamming is occurring
 
-uint64 timestamp_velocity	# Timestamp for velocity informations 
-float32 vel_m_s			# GPS ground speed (m/s) 
-float32 vel_n_m_s		# GPS ground speed in m/s 
-float32 vel_e_m_s		# GPS ground speed in m/s 
-float32 vel_d_m_s		# GPS ground speed in m/s 
-float32 cog_rad			# Course over ground (NOT heading, but direction of movement) in rad, -PI..PI 
-bool vel_ned_valid		# Flag to indicate if NED speed is valid 
+uint64 timestamp_velocity	# Time of the velocity estimates since system start, (microseconds)
+float32 vel_m_s			# GPS ground speed, (metres/sec) 
+float32 vel_n_m_s		# GPS North velocity, (metres/sec) 
+float32 vel_e_m_s		# GPS East velocity, (metres/sec)
+float32 vel_d_m_s		# GPS Down velocity, (metres/sec) 
+float32 cog_rad			# Course over ground (NOT heading, but direction of movement), -PI..PI, (radians) 
+bool vel_ned_valid		# True if NED velocity is valid 
 
-uint64 timestamp_time		# Timestamp for time information 
+uint64 timestamp_time		# Time of the UTC timestamp since system start, (microseconds) 
 uint64 time_utc_usec		# Timestamp (microseconds, UTC), this is the timestamp which comes from the gps module. It might be unavailable right after cold start, indicated by a value of 0 
 
 uint8 satellites_used		# Number of satellites used 
diff --git a/msg/vehicle_local_position.msg b/msg/vehicle_local_position.msg
index 4da027a..89c141c 100644
--- a/msg/vehicle_local_position.msg
+++ b/msg/vehicle_local_position.msg
@@ -1,36 +1,36 @@
 # Fused local position in NED.
 
-uint64 timestamp		# Time of this estimate, in microseconds since system start
-bool xy_valid			# true if x and y are valid
-bool z_valid			# true if z is valid
-bool v_xy_valid		# true if vy and vy are valid
-bool v_z_valid			# true if vz is valid
+uint64 timestamp			# Time of this estimate since system start, (microseconds)
+bool xy_valid				# true if x and y are valid
+bool z_valid				# true if z is valid
+bool v_xy_valid				# true if vy and vy are valid
+bool v_z_valid				# true if vz is valid
 
 # Position in local NED frame
-float32 x				# X position in meters in NED earth-fixed frame
-float32 y				# X position in meters in NED earth-fixed frame
-float32 z				# Z position in meters in NED earth-fixed frame (negative altitude)
+float32 x				# North position in NED earth-fixed frame, (metres)
+float32 y				# East position in NED earth-fixed frame, (metres)
+float32 z				# Down position (negative altitude) in NED earth-fixed frame, (metres)
 
 # Velocity in NED frame
-float32 vx 				# Ground X Speed (Latitude), m/s in NED
-float32 vy				# Ground Y Speed (Longitude), m/s in NED
-float32 vz				# Ground Z Speed (Altitude), m/s	in NED
+float32 vx 				# North velocity in NED earth-fixed frame, (metres/sec)
+float32 vy				# East velocity in NED earth-fixed frame, (metres/sec)
+float32 vz				# Down velocity in NED earth-fixed frame, (metres/sec)
 
 # Heading
-float32 yaw
+float32 yaw				# Euler yaw angle transforming the tangent plane relative to NED earth-fixed frame, -PI..+PI,  (radians) 
 
-# Reference position in GPS / WGS84 frame
-bool xy_global			# true if position (x, y) is valid and has valid global reference (ref_lat, ref_lon)
-bool z_global			# true if z is valid and has valid global reference (ref_alt)
-uint64 ref_timestamp	# Time when reference position was set
-float64 ref_lat		# Reference point latitude in degrees
-float64 ref_lon		# Reference point longitude in degrees
-float32 ref_alt			# Reference altitude AMSL in meters, MUST be set to current (not at reference point!) ground level
+# Position of reference point (local NED frame origin) in global (GPS / WGS84) frame
+bool xy_global				# true if position (x, y) is valid and has valid global reference (ref_lat, ref_lon)
+bool z_global				# true if z is valid and has valid global reference (ref_alt)
+uint64 ref_timestamp			# Time when reference position was set since system start, (microseconds)
+float64 ref_lat				# Reference point latitude, (degrees)
+float64 ref_lon				# Reference point longitude, (degrees)
+float32 ref_alt				# Reference altitude AMSL, MUST be set to current (not at reference point!) ground level, (metres)
 
 # Distance to surface
-float32 dist_bottom		# Distance to bottom surface (ground)
-float32 dist_bottom_rate		# Distance to bottom surface (ground) change rate
-uint64 surface_bottom_timestamp		# Time when new bottom surface found
-bool dist_bottom_valid	# true if distance to bottom surface is valid
-float32 eph
-float32 epv
+float32 dist_bottom			# Distance from from bottom surface to ground, (metres)
+float32 dist_bottom_rate		# Rate of change of distance from bottom surface to ground, (metres/sec)
+uint64 surface_bottom_timestamp		# Time when new bottom surface found since system start, (microseconds)
+bool dist_bottom_valid			# true if distance to bottom surface is valid
+float32 eph				# Standard deviation of horizontal position error, (metres)
+float32 epv				# Standard deviation of vertical position error, (metres)
\ No newline at end of file
diff --git a/msg/vehicle_rates_setpoint.msg b/msg/vehicle_rates_setpoint.msg
index 834113c..4fa09b5 100644
--- a/msg/vehicle_rates_setpoint.msg
+++ b/msg/vehicle_rates_setpoint.msg
@@ -1,6 +1,16 @@
+###############################################################################################
+# The vehicle_rates_setpoint.msg needs to be in sync with the virtual setpoint messages
+#
+# Please keep the following messages identical;
+#	vehicle_rates_setpoint.msg
+#	mc_virtual_rates_setpoint.msg
+#	fw_virtual_rates_setpoint.msg
+#
+###############################################################################################
+
 uint64 timestamp    # in microseconds since system start
 
 float32 roll	    # body angular rates in NED frame
 float32 pitch	    # body angular rates in NED frame
-float32 yaw	    # body angular rates in NED frame
+float32 yaw			# body angular rates in NED frame
 float32 thrust	    # thrust normalized to 0..1
diff --git a/msg/vehicle_status.msg b/msg/vehicle_status.msg
index 0748442..4582504 100644
--- a/msg/vehicle_status.msg
+++ b/msg/vehicle_status.msg
@@ -7,7 +7,12 @@ uint8 MAIN_STATE_AUTO_LOITER = 4
 uint8 MAIN_STATE_AUTO_RTL = 5
 uint8 MAIN_STATE_ACRO = 6
 uint8 MAIN_STATE_OFFBOARD = 7
-uint8 MAIN_STATE_MAX = 8
+uint8 MAIN_STATE_STAB = 8
+uint8 MAIN_STATE_RATTITUDE = 9
+uint8 MAIN_STATE_AUTO_TAKEOFF = 10
+uint8 MAIN_STATE_AUTO_LAND = 11
+uint8 MAIN_STATE_AUTO_FOLLOW_TARGET = 12
+uint8 MAIN_STATE_MAX = 13
 
 # If you change the order, add or remove arming_state_t states make sure to update the arrays
 # in state_machine_helper.cpp as well.
@@ -35,11 +40,16 @@ uint8 NAVIGATION_STATE_AUTO_RTGS = 7		# Auto return to groundstation on data lin
 uint8 NAVIGATION_STATE_AUTO_LANDENGFAIL = 8 	# Auto land on engine failure
 uint8 NAVIGATION_STATE_AUTO_LANDGPSFAIL = 9	# Auto land on gps failure (e.g. open loop loiter down)
 uint8 NAVIGATION_STATE_ACRO = 10		# Acro mode
-uint8 NAVIGATION_STATE_LAND = 11		# Land mode
+uint8 NAVIGATION_STATE_UNUSED = 11		# Free slot
 uint8 NAVIGATION_STATE_DESCEND = 12		# Descend mode (no position control)
 uint8 NAVIGATION_STATE_TERMINATION = 13		# Termination mode
 uint8 NAVIGATION_STATE_OFFBOARD = 14
-uint8 NAVIGATION_STATE_MAX = 15
+uint8 NAVIGATION_STATE_STAB = 15		# Stabilized mode
+uint8 NAVIGATION_STATE_RATTITUDE = 16		# Rattitude (aka "flip") mode
+uint8 NAVIGATION_STATE_AUTO_TAKEOFF = 17	# Takeoff
+uint8 NAVIGATION_STATE_AUTO_LAND = 18		# Land
+uint8 NAVIGATION_STATE_AUTO_FOLLOW_TARGET = 19	# Auto Follow
+uint8 NAVIGATION_STATE_MAX = 20
 
 # VEHICLE_MODE_FLAG, same as MAV_MODE_FLAG of MAVLink 1.0 protocol
 uint8 VEHICLE_MODE_FLAG_SAFETY_ARMED = 128
@@ -77,6 +87,13 @@ uint8 VEHICLE_TYPE_VTOL_HEXAROTOR = 21 		# Vtol with six engines
 uint8 VEHICLE_TYPE_VTOL_OCTOROTOR = 22		# Vtol with eight engines
 uint8 VEHICLE_TYPE_ENUM_END = 23
 
+# VEHICLE_VTOL_STATE, should match 1:1 MAVLinks's MAV_VTOL_STATE
+uint8 VEHICLE_VTOL_STATE_UNDEFINED = 0
+uint8 VEHICLE_VTOL_STATE_TRANSITION_TO_FW = 1
+uint8 VEHICLE_VTOL_STATE_TRANSITION_TO_MC = 2
+uint8 VEHICLE_VTOL_STATE_MC = 3
+uint8 VEHICLE_VTOL_STATE_FW = 4
+
 uint8 VEHICLE_BATTERY_WARNING_NONE = 0	    # no battery low voltage warning active
 uint8 VEHICLE_BATTERY_WARNING_LOW = 1	    # warning of low voltage
 uint8 VEHICLE_BATTERY_WARNING_CRITICAL = 2  # alerting of critical voltage
@@ -91,6 +108,7 @@ uint16 counter   # incremented by the writing thread everytime new data is store
 uint64 timestamp # in microseconds since system start, is set whenever the writing thread stores new data
 
 uint8 main_state		    	# main state machine
+uint8 main_state_prev       # previous main state
 uint8 nav_state				# set navigation state machine to specified value
 uint8 arming_state			# current arming state
 uint8 hil_state				# current hil state
@@ -104,14 +122,16 @@ uint32 component_id			# subsystem / component id, inspired by MAVLink's componen
 bool is_rotary_wing			# True if system is in rotary wing configuration, so for a VTOL this is only true while flying as a multicopter
 bool is_vtol				# True if the system is VTOL capable
 bool vtol_fw_permanent_stab		# True if vtol should stabilize attitude for fw in manual mode
+bool in_transition_mode			# True if VTOL is doing a transition
 
 bool condition_battery_voltage_valid
 bool condition_system_in_air_restore		# true if we can restore in mid air
 bool condition_system_sensors_initialized
+bool condition_system_prearm_error_reported	# true if errors have already been reported 
+bool condition_system_hotplug_timeout		# true if the hotplug sensor search is over
 bool condition_system_returned_to_home
 bool condition_auto_mission_available
 bool condition_global_position_valid		# set to true by the commander app if the quality of the position estimate is good enough to use it for navigation
-bool condition_launch_position_valid		# indicates a valid launch position
 bool condition_home_position_valid		# indicates a valid home position (a valid home position is not always a valid launch)
 bool condition_local_position_valid
 bool condition_local_altitude_valid
@@ -133,9 +153,11 @@ bool data_link_lost_cmd				# datalink to GCS lost mode commanded
 uint8 data_link_lost_counter			# counts unique data link lost events
 bool engine_failure				# Set to true if an engine failure is detected
 bool engine_failure_cmd				# Set to true if an engine failure mode is commanded
+bool vtol_transition_failure		# Set to true if vtol transition failed
+bool vtol_transition_failure_cmd	# Set to true if vtol transition failure mode is commanded
 bool gps_failure				# Set to true if a gps failure is detected
 bool gps_failure_cmd				# Set to true if a gps failure mode is commanded
-
+bool mission_failure				# Set to true if mission could not continue/finish
 bool barometer_failure				# Set to true if a barometer failure is detected
 
 bool offboard_control_signal_found_once
@@ -168,3 +190,4 @@ bool circuit_breaker_engaged_power_check
 bool circuit_breaker_engaged_airspd_check
 bool circuit_breaker_engaged_enginefailure_check
 bool circuit_breaker_engaged_gpsfailure_check
+bool cb_usb
diff --git a/msg/vtol_vehicle_status.msg b/msg/vtol_vehicle_status.msg
index 5b2dc99..6fce6b3 100644
--- a/msg/vtol_vehicle_status.msg
+++ b/msg/vtol_vehicle_status.msg
@@ -1,4 +1,6 @@
-uint64 timestamp		# Microseconds since system boot
-bool vtol_in_rw_mode		# true: vtol vehicle is in rotating wing mode
-bool fw_permanent_stab		# In fw mode stabilize attitude even if in manual mode
-float32 airspeed_tot		# Estimated airspeed over control surfaces
+uint64 timestamp				# Microseconds since system boot
+bool vtol_in_rw_mode			# true: vtol vehicle is in rotating wing mode
+bool vtol_in_trans_mode
+bool vtol_transition_failsafe	# vtol in transition failsafe mode
+bool fw_permanent_stab			# In fw mode stabilize attitude even if in manual mode
+float32 airspeed_tot			# Estimated airspeed over control surfaces
diff --git a/src/drivers/airspeed/airspeed.cpp b/src/drivers/airspeed/airspeed.cpp
index f235264..a9c1e2c 100644
--- a/src/drivers/airspeed/airspeed.cpp
+++ b/src/drivers/airspeed/airspeed.cpp
@@ -243,12 +243,12 @@ Airspeed::ioctl(struct file *filp, int cmd, unsigned long arg)
 			if ((arg < 1) || (arg > 100))
 				return -EINVAL;
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/boards/aerocore/aerocore_init.c b/src/drivers/boards/aerocore/aerocore_init.c
index 3bdb0d4..7268694 100644
--- a/src/drivers/boards/aerocore/aerocore_init.c
+++ b/src/drivers/boards/aerocore/aerocore_init.c
@@ -54,7 +54,7 @@
 
 #include <nuttx/arch.h>
 #include <nuttx/spi.h>
-#include <nuttx/i2c.h>
+#include <nuttx/i2c/i2c_master.h>
 #include <nuttx/mmcsd.h>
 #include <nuttx/analog/adc.h>
 #include <nuttx/gran.h>
diff --git a/src/drivers/device/cdev.cpp b/src/drivers/device/cdev.cpp
index 3bc05b0..2b93b65 100644
--- a/src/drivers/device/cdev.cpp
+++ b/src/drivers/device/cdev.cpp
@@ -325,13 +325,13 @@ void
 CDev::poll_notify(pollevent_t events)
 {
 	/* lock against poll() as well as other wakeups */
-	irqstate_t state = irqsave();
+	irqstate_t state = up_irq_save();
 
 	for (unsigned i = 0; i < _max_pollwaiters; i++)
 		if (nullptr != _pollset[i])
 			poll_notify_one(_pollset[i], events);
 
-	irqrestore(state);
+	up_irq_restore(state);
 }
 
 void
diff --git a/src/drivers/device/i2c_nuttx.cpp b/src/drivers/device/i2c_nuttx.cpp
index 092ecd1..f61a69e 100644
--- a/src/drivers/device/i2c_nuttx.cpp
+++ b/src/drivers/device/i2c_nuttx.cpp
@@ -41,7 +41,10 @@
  */
 
 #include "i2c.h"
-
+extern "C"
+{
+#include <stm32.h>
+}
 namespace device
 {
 
@@ -75,7 +78,9 @@ I2C::I2C(const char *name,
 I2C::~I2C()
 {
 	if (_dev) {
-		up_i2cuninitialize(_dev);
+//		up_i2cuninitialize(_dev);
+		(void)stm32_i2cbus_uninitialize(_dev);
+
 		_dev = nullptr;
 	}
 }
@@ -104,7 +109,7 @@ I2C::init()
 	unsigned bus_index;
 
 	// attach to the i2c bus
-	_dev = up_i2cinitialize(_bus);
+	_dev = stm32_i2cbus_initialize(_bus);
 
 	if (_dev == nullptr) {
 		debug("failed to init I2C");
@@ -119,7 +124,7 @@ I2C::init()
 	// abort if the max frequency we allow (the frequency we ask)
 	// is smaller than the bus frequency
 	if (_bus_clocks[bus_index] > _frequency) {
-		(void)up_i2cuninitialize(_dev);
+		(void)stm32_i2cbus_uninitialize(_dev);
 		_dev = nullptr;
 		log("FAIL: too slow for bus #%u: %u KHz, device max: %u KHz)",
 			_bus, _bus_clocks[bus_index] / 1000, _frequency / 1000);
@@ -142,7 +147,7 @@ I2C::init()
 	// This is necessary as automatically lowering the bus speed
 	// for maximum compatibility could induce timing issues on
 	// critical sensors the adopter might be unaware of.
-	I2C_SETFREQUENCY(_dev, _bus_clocks[bus_index]);
+	//I2C_SETFREQUENCY(_dev, _bus_clocks[bus_index]);
 
 	// call the probe function to check whether the device is present
 	ret = probe();
@@ -166,7 +171,7 @@ I2C::init()
 
 out:
 	if ((ret != OK) && (_dev != nullptr)) {
-		up_i2cuninitialize(_dev);
+		(void)stm32_i2cbus_uninitialize(_dev);
 		_dev = nullptr;
 	}
 	return ret;
@@ -218,8 +223,9 @@ I2C::transfer(const uint8_t *send, unsigned send_len, uint8_t *recv, unsigned re
 			break;
 
 		/* if we have already retried once, or we are going to give up, then reset the bus */
-		if ((retry_count >= 1) || (retry_count >= _retries))
-			up_i2creset(_dev);
+		if ((retry_count >= 1) || (retry_count >= _retries)){
+			//up_i2creset(_dev);
+		}
 
 	} while (retry_count++ < _retries);
 
@@ -246,8 +252,9 @@ I2C::transfer(i2c_msg_s *msgv, unsigned msgs)
 			break;
 
 		/* if we have already retried once, or we are going to give up, then reset the bus */
-		if ((retry_count >= 1) || (retry_count >= _retries))
-			up_i2creset(_dev);
+		if ((retry_count >= 1) || (retry_count >= _retries)){
+			//up_i2creset(_dev);
+		}
 
 	} while (retry_count++ < _retries);
 
diff --git a/src/drivers/device/i2c_nuttx.h b/src/drivers/device/i2c_nuttx.h
index 97ab256..5d87a36 100644
--- a/src/drivers/device/i2c_nuttx.h
+++ b/src/drivers/device/i2c_nuttx.h
@@ -44,6 +44,7 @@
 
 #include <px4_i2c.h>
 
+struct i2c_master_s;
 namespace device __EXPORT
 {
 
@@ -142,7 +143,8 @@ protected:
 private:
 	uint16_t		_address;
 	uint32_t		_frequency;
-	px4_i2c_dev_t		*_dev;
+	//px4_i2c_dev_t		*_dev;
+	FAR struct i2c_master_s		*_dev;
 
 	I2C(const device::I2C &);
 	I2C operator=(const device::I2C &);
diff --git a/src/drivers/device/spi.cpp b/src/drivers/device/spi.cpp
index 14f6d57..187a3aa 100644
--- a/src/drivers/device/spi.cpp
+++ b/src/drivers/device/spi.cpp
@@ -48,6 +48,7 @@
 #include <nuttx/arch.h>
 
 #include "spi.h"
+#include <stm32.h>
 
 #ifndef CONFIG_SPI_EXCHANGE
 # error This driver requires CONFIG_SPI_EXCHANGE
@@ -95,7 +96,9 @@ SPI::init()
 
 	/* attach to the spi bus */
 	if (_dev == nullptr)
-		_dev = up_spiinitialize(_bus);
+		//_dev = up_spiinitialize(_bus);
+
+		_dev = stm32_spibus_initialize(_bus);
 
 	if (_dev == nullptr) {
 		debug("failed to init SPI");
@@ -151,9 +154,9 @@ SPI::transfer(uint8_t *send, uint8_t *recv, unsigned len)
 	default:
 	case LOCK_PREEMPTION:
 		{
-			irqstate_t state = irqsave();
+			irqstate_t state = up_irq_save();
 			result = _transfer(send, recv, len);
-			irqrestore(state);
+			up_irq_restore(state);
 		}
 		break;
 	case LOCK_THREADS:
diff --git a/src/drivers/hmc5883/hmc5883.cpp b/src/drivers/hmc5883/hmc5883.cpp
index cd6badd..cb0a2c4 100644
--- a/src/drivers/hmc5883/hmc5883.cpp
+++ b/src/drivers/hmc5883/hmc5883.cpp
@@ -677,12 +677,12 @@ HMC5883::ioctl(struct file *filp, int cmd, unsigned long arg)
 			if ((arg < 1) || (arg > 100))
 				return -EINVAL;
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/l3gd20/l3gd20.cpp b/src/drivers/l3gd20/l3gd20.cpp
index 66ef6c9..b7c9e30 100644
--- a/src/drivers/l3gd20/l3gd20.cpp
+++ b/src/drivers/l3gd20/l3gd20.cpp
@@ -647,12 +647,12 @@ L3GD20::ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
diff --git a/src/drivers/ll40ls/LidarLiteI2C.cpp b/src/drivers/ll40ls/LidarLiteI2C.cpp
index 964ad97..f8ef892 100644
--- a/src/drivers/ll40ls/LidarLiteI2C.cpp
+++ b/src/drivers/ll40ls/LidarLiteI2C.cpp
@@ -220,14 +220,14 @@ int LidarLiteI2C::ioctl(struct file *filp, int cmd, unsigned long arg)
 				return -EINVAL;
 			}
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
 
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/lsm303d/lsm303d.cpp b/src/drivers/lsm303d/lsm303d.cpp
index c1e1f37..529e7dd 100644
--- a/src/drivers/lsm303d/lsm303d.cpp
+++ b/src/drivers/lsm303d/lsm303d.cpp
@@ -907,12 +907,12 @@ LSM303D::ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_accel_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
@@ -1041,12 +1041,12 @@ LSM303D::mag_ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_mag_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
diff --git a/src/drivers/mb12xx/mb12xx.cpp b/src/drivers/mb12xx/mb12xx.cpp
index a67db0b..0a8e956 100644
--- a/src/drivers/mb12xx/mb12xx.cpp
+++ b/src/drivers/mb12xx/mb12xx.cpp
@@ -432,14 +432,14 @@ MB12XX::ioctl(struct file *filp, int cmd, unsigned long arg)
 				return -EINVAL;
 			}
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
 
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/mkblctrl/mkblctrl.cpp b/src/drivers/mkblctrl/mkblctrl.cpp
index 3448b57..c3276bb 100644
--- a/src/drivers/mkblctrl/mkblctrl.cpp
+++ b/src/drivers/mkblctrl/mkblctrl.cpp
@@ -59,7 +59,7 @@
 #include <unistd.h>
 
 #include <nuttx/arch.h>
-#include <nuttx/i2c.h>
+#include <nuttx/i2c/i2c_master.h>
 
 #include <board_config.h>
 
diff --git a/src/drivers/mpu6000/mpu6000.cpp b/src/drivers/mpu6000/mpu6000.cpp
index 1b30019..f8805c7 100644
--- a/src/drivers/mpu6000/mpu6000.cpp
+++ b/src/drivers/mpu6000/mpu6000.cpp
@@ -692,7 +692,7 @@ int MPU6000::reset()
 	uint8_t tries = 5;
 	while (--tries != 0) {
 		irqstate_t state;
-		state = irqsave();
+		state = up_irq_save();
 
 		write_reg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
 		up_udelay(10000);
@@ -705,7 +705,7 @@ int MPU6000::reset()
 
 		// Disable I2C bus (recommended on datasheet)
 		write_checked_reg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
-		irqrestore(state);
+		up_irq_restore(state);
 
 		if (read_reg(MPUREG_PWR_MGMT_1) == MPU_CLK_SEL_PLLGYROZ) {
 			break;
@@ -1267,12 +1267,12 @@ MPU6000::ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_accel_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
@@ -1354,12 +1354,12 @@ MPU6000::gyro_ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_gyro_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
diff --git a/src/drivers/mpu9250/mpu9250.cpp b/src/drivers/mpu9250/mpu9250.cpp
index 61dc167..5105e31 100644
--- a/src/drivers/mpu9250/mpu9250.cpp
+++ b/src/drivers/mpu9250/mpu9250.cpp
@@ -1079,12 +1079,12 @@ MPU9250::ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_accel_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
@@ -1166,12 +1166,12 @@ MPU9250::gyro_ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_gyro_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
diff --git a/src/drivers/ms5611/ms5611_nuttx.cpp b/src/drivers/ms5611/ms5611_nuttx.cpp
index 2e98de1..a7dcde7 100644
--- a/src/drivers/ms5611/ms5611_nuttx.cpp
+++ b/src/drivers/ms5611/ms5611_nuttx.cpp
@@ -474,12 +474,12 @@ MS5611::ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 		return OK;
 	}
 
diff --git a/src/drivers/pwm_input/pwm_input.cpp b/src/drivers/pwm_input/pwm_input.cpp
index 74d652d..9c20351 100644
--- a/src/drivers/pwm_input/pwm_input.cpp
+++ b/src/drivers/pwm_input/pwm_input.cpp
@@ -316,7 +316,7 @@ void PWMIN::_timer_init(void)
 {
 	/* run with interrupts disabled in case the timer is already
 	 * setup. We don't want it firing while we are doing the setup */
-	irqstate_t flags = irqsave();
+	irqstate_t flags = up_irq_save();
 	stm32_configgpio(GPIO_PWM_IN);
 
 	/* claim our interrupt vector */
@@ -362,7 +362,7 @@ void PWMIN::_timer_init(void)
 	/* enable interrupts */
 	up_enable_irq(PWMIN_TIMER_VECTOR);
 
-	irqrestore(flags);
+	up_irq_restore(flags);
 
 	_timer_started = true;
 
@@ -403,14 +403,14 @@ PWMIN::ioctl(struct file *filp, int cmd, unsigned long arg)
 				return -EINVAL;
 			}
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
 
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/px4flow/px4flow.cpp b/src/drivers/px4flow/px4flow.cpp
index 0704f16..12b2a13 100644
--- a/src/drivers/px4flow/px4flow.cpp
+++ b/src/drivers/px4flow/px4flow.cpp
@@ -350,14 +350,14 @@ PX4FLOW::ioctl(struct file *filp, int cmd, unsigned long arg)
 				return -EINVAL;
 			}
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
 
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/px4io/px4io_serial.cpp b/src/drivers/px4io/px4io_serial.cpp
index 566d43f..dc94df9 100644
--- a/src/drivers/px4io/px4io_serial.cpp
+++ b/src/drivers/px4io/px4io_serial.cpp
@@ -74,8 +74,8 @@ device::Device	*PX4IO_serial_interface();
 
 /* serial register accessors */
 #define REG(_x)		(*(volatile uint32_t *)(PX4IO_SERIAL_BASE + _x))
-#define rSR		REG(STM32_USART_SR_OFFSET)
-#define rDR		REG(STM32_USART_DR_OFFSET)
+#define rSR		REG(STM32_USART_ISR_OFFSET)
+#define rDR		REG(STM32_USART_RDR_OFFSET)
 #define rBRR		REG(STM32_USART_BRR_OFFSET)
 #define rCR1		REG(STM32_USART_CR1_OFFSET)
 #define rCR2		REG(STM32_USART_CR2_OFFSET)
@@ -265,7 +265,7 @@ PX4IO_serial::init()
 	uint32_t usartdiv32 = PX4IO_SERIAL_CLOCK / (PX4IO_SERIAL_BITRATE / 2);
 	uint32_t mantissa = usartdiv32 >> 5;
 	uint32_t fraction = (usartdiv32 - (mantissa << 5) + 1) >> 1;
-	rBRR = (mantissa << USART_BRR_MANT_SHIFT) | (fraction << USART_BRR_FRAC_SHIFT);
+	rBRR = (mantissa << USART_BRR_4_7_SHIFT) | (fraction << USART_BRR_0_3_SHIFT);
 
 	/* attach serial interrupt handler */
 	irq_attach(PX4IO_SERIAL_VECTOR, _interrupt);
@@ -295,7 +295,7 @@ PX4IO_serial::ioctl(unsigned operation, unsigned &arg)
 	case 1:		/* XXX magic number - test operation */
 		switch (arg) {
 		case 0:
-			lowsyslog("test 0\n");
+			syslog(LOG_INFO, "test 0\n");
 
 			/* kill DMA, this is a PIO test */
 			stm32_dmastop(_tx_dma);
@@ -303,7 +303,7 @@ PX4IO_serial::ioctl(unsigned operation, unsigned &arg)
 			rCR3 &= ~(USART_CR3_DMAR | USART_CR3_DMAT);
 
 			for (;;) {
-				while (!(rSR & USART_SR_TXE))
+				while (!(rSR & USART_ISR_TXE))
 					;
 				rDR = 0x55;
 			}
@@ -319,7 +319,7 @@ PX4IO_serial::ioctl(unsigned operation, unsigned &arg)
 						fails++;
 						
 					if (count >= 5000) {
-						lowsyslog("==== test 1 : %u failures ====\n", fails);
+						syslog(LOG_INFO, "==== test 1 : %u failures ====\n", fails);
 						perf_print_counter(_pc_txns);
 						perf_print_counter(_pc_dmasetup);
 						perf_print_counter(_pc_retries);
@@ -336,7 +336,7 @@ PX4IO_serial::ioctl(unsigned operation, unsigned &arg)
 				return 0;
 			}
 		case 2:
-			lowsyslog("test 2\n");
+			syslog(LOG_INFO, "test 2\n");
 			return 0;
 		}
 	default:
@@ -479,7 +479,7 @@ PX4IO_serial::_wait_complete()
 	 */
 	stm32_dmasetup(
 		_rx_dma,
-		PX4IO_SERIAL_BASE + STM32_USART_DR_OFFSET,
+		PX4IO_SERIAL_BASE + STM32_USART_RDR_OFFSET,
 		reinterpret_cast<uint32_t>(&_dma_buffer),
 		sizeof(_dma_buffer),
 		DMA_SCR_CIRC		|	/* XXX see note above */
@@ -498,7 +498,7 @@ PX4IO_serial::_wait_complete()
 	_dma_buffer.crc = crc_packet(&_dma_buffer);
 	stm32_dmasetup(
 		_tx_dma,
-		PX4IO_SERIAL_BASE + STM32_USART_DR_OFFSET,
+		PX4IO_SERIAL_BASE + STM32_USART_TDR_OFFSET,
 		reinterpret_cast<uint32_t>(&_dma_buffer),
 		PKT_SIZE(_dma_buffer),
 		DMA_SCR_DIR_M2P		|
@@ -558,7 +558,7 @@ PX4IO_serial::_wait_complete()
 		}
 
 		/* we might? see this for EINTR */
-		lowsyslog("unexpected ret %d/%d\n", ret, errno);
+		syslog(LOG_INFO, "unexpected ret %d/%d\n", ret, errno);
 	}
 
 	/* reset DMA status */
@@ -588,7 +588,7 @@ PX4IO_serial::_do_rx_dma_callback(unsigned status)
 
 		/* check for packet overrun - this will occur after DMA completes */
 		uint32_t sr = rSR;
-		if (sr & (USART_SR_ORE | USART_SR_RXNE)) {
+		if (sr & (USART_ISR_ORE | USART_ISR_RXNE)) {
 			(void)rDR;
 			status = DMA_STATUS_TEIF;
 		}
@@ -618,9 +618,9 @@ PX4IO_serial::_do_interrupt()
 	uint32_t sr = rSR;	/* get UART status register */
 	(void)rDR;		/* read DR to clear status */
 
-	if (sr & (USART_SR_ORE |	/* overrun error - packet was too big for DMA or DMA was too slow */
-		USART_SR_NE |		/* noise error - we have lost a byte due to noise */
-		USART_SR_FE)) {		/* framing error - start/stop bit lost or line break */
+	if (sr & (USART_ISR_ORE |	/* overrun error - packet was too big for DMA or DMA was too slow */
+		USART_ISR_NF |		/* noise error - we have lost a byte due to noise */
+		USART_ISR_FE)) {		/* framing error - start/stop bit lost or line break */
 		
 		/* 
 		 * If we are in the process of listening for something, these are all fatal;
@@ -642,7 +642,7 @@ PX4IO_serial::_do_interrupt()
 		return;
 	}
 
-	if (sr & USART_SR_IDLE) {
+	if (sr & USART_ISR_IDLE) {
 
 		/* if there is DMA reception going on, this is a short packet */
 		if (_rx_dma_status == _dma_status_waiting) {
diff --git a/src/drivers/sf0x/sf0x.cpp b/src/drivers/sf0x/sf0x.cpp
index 5b1b37f..bacbce5 100644
--- a/src/drivers/sf0x/sf0x.cpp
+++ b/src/drivers/sf0x/sf0x.cpp
@@ -422,14 +422,14 @@ SF0X::ioctl(struct file *filp, int cmd, unsigned long arg)
 				return -EINVAL;
 			}
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
 
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/drivers/stm32/adc/adc.cpp b/src/drivers/stm32/adc/adc.cpp
index 465ee69..3bb4ffe 100644
--- a/src/drivers/stm32/adc/adc.cpp
+++ b/src/drivers/stm32/adc/adc.cpp
@@ -58,7 +58,7 @@
 #include <drivers/drv_hrt.h>
 #include <drivers/drv_adc.h>
 
-#include <arch/stm32/chip.h>
+#include <arch/stm32f7/chip.h>
 #include <stm32.h>
 #include <stm32_gpio.h>
 
@@ -260,9 +260,9 @@ ADC::read(file *filp, char *buffer, size_t len)
 		len = maxsize;
 
 	/* block interrupts while copying samples to avoid racing with an update */
-	irqstate_t flags = irqsave();
+	irqstate_t flags = up_irq_save();
 	memcpy(buffer, _samples, len);
-	irqrestore(flags);
+	up_irq_restore(flags);
 
 	return len;
 }
diff --git a/src/drivers/stm32/drv_hrt.c b/src/drivers/stm32/drv_hrt.c
index e37b750..2cb5559 100644
--- a/src/drivers/stm32/drv_hrt.c
+++ b/src/drivers/stm32/drv_hrt.c
@@ -648,7 +648,7 @@ hrt_absolute_time(void)
 
 	/*
 	 * Counter state.  Marked volatile as they may change
-	 * inside this routine but outside the irqsave/restore
+	 * inside this routine but outside the up_irq_save/restore
 	 * pair.  Discourage the compiler from moving loads/stores
 	 * to these outside of the protected range.
 	 */
@@ -656,7 +656,7 @@ hrt_absolute_time(void)
 	static volatile uint32_t last_count;
 
 	/* prevent re-entry */
-	flags = irqsave();
+	flags = up_irq_save();
 
 	/* get the current counter value */
 	count = rCNT;
@@ -677,7 +677,7 @@ hrt_absolute_time(void)
 	/* compute the current time */
 	abstime = HRT_COUNTER_SCALE(base_time + count);
 
-	irqrestore(flags);
+	up_irq_restore(flags);
 
 	return abstime;
 }
@@ -713,11 +713,11 @@ abstime_to_ts(struct timespec *ts, hrt_abstime abstime)
 hrt_abstime
 hrt_elapsed_time(const volatile hrt_abstime *then)
 {
-	irqstate_t flags = irqsave();
+	irqstate_t flags = up_irq_save();
 
 	hrt_abstime delta = hrt_absolute_time() - *then;
 
-	irqrestore(flags);
+	up_irq_restore(flags);
 
 	return delta;
 }
@@ -728,11 +728,11 @@ hrt_elapsed_time(const volatile hrt_abstime *then)
 hrt_abstime
 hrt_store_absolute_time(volatile hrt_abstime *now)
 {
-	irqstate_t flags = irqsave();
+	irqstate_t flags = up_irq_save();
 
 	hrt_abstime ts = hrt_absolute_time();
 
-	irqrestore(flags);
+	up_irq_restore(flags);
 
 	return ts;
 }
@@ -790,7 +790,7 @@ hrt_call_every(struct hrt_call *entry, hrt_abstime delay, hrt_abstime interval,
 static void
 hrt_call_internal(struct hrt_call *entry, hrt_abstime deadline, hrt_abstime interval, hrt_callout callout, void *arg)
 {
-	irqstate_t flags = irqsave();
+	irqstate_t flags = up_irq_save();
 
 	/* if the entry is currently queued, remove it */
 	/* note that we are using a potentially uninitialised
@@ -810,7 +810,7 @@ hrt_call_internal(struct hrt_call *entry, hrt_abstime deadline, hrt_abstime inte
 
 	hrt_call_enter(entry);
 
-	irqrestore(flags);
+	up_irq_restore(flags);
 }
 
 /**
@@ -830,7 +830,7 @@ hrt_called(struct hrt_call *entry)
 void
 hrt_cancel(struct hrt_call *entry)
 {
-	irqstate_t flags = irqsave();
+	irqstate_t flags = up_irq_save();
 
 	sq_rem(&entry->link, &callout_queue);
 	entry->deadline = 0;
@@ -840,7 +840,7 @@ hrt_cancel(struct hrt_call *entry)
 	 */
 	entry->period = 0;
 
-	irqrestore(flags);
+	up_irq_restore(flags);
 }
 
 static void
diff --git a/src/drivers/stm32/tone_alarm/tone_alarm.cpp b/src/drivers/stm32/tone_alarm/tone_alarm.cpp
index ca4794b..62cf615 100644
--- a/src/drivers/stm32/tone_alarm/tone_alarm.cpp
+++ b/src/drivers/stm32/tone_alarm/tone_alarm.cpp
@@ -107,7 +107,7 @@
 #include <board_config.h>
 #include <drivers/drv_hrt.h>
 
-#include <arch/stm32/chip.h>
+#include <arch/stm32f7/chip.h>
 #include <up_internal.h>
 #include <up_arch.h>
 
@@ -674,7 +674,7 @@ ToneAlarm::next_note()
 
 	// tune looks bad (unexpected EOF, bad character, etc.)
 tune_error:
-	lowsyslog("tune error\n");
+	syslog(LOG_INFO, "tune error\n");
 	_repeat = false;		// don't loop on error
 
 	// stop (and potentially restart) the tune
diff --git a/src/drivers/trone/trone.cpp b/src/drivers/trone/trone.cpp
index 82122a3..4009828 100644
--- a/src/drivers/trone/trone.cpp
+++ b/src/drivers/trone/trone.cpp
@@ -433,14 +433,14 @@ TRONE::ioctl(struct file *filp, int cmd, unsigned long arg)
 				return -EINVAL;
 			}
 
-			irqstate_t flags = irqsave();
+			irqstate_t flags = up_irq_save();
 
 			if (!_reports->resize(arg)) {
-				irqrestore(flags);
+				up_irq_restore(flags);
 				return -ENOMEM;
 			}
 
-			irqrestore(flags);
+			up_irq_restore(flags);
 
 			return OK;
 		}
diff --git a/src/lib/mathlib/CMSIS/Include/arm_math.h b/src/lib/mathlib/CMSIS/Include/arm_math.h
index fafa150..7a37f40 100644
--- a/src/lib/mathlib/CMSIS/Include/arm_math.h
+++ b/src/lib/mathlib/CMSIS/Include/arm_math.h
@@ -289,8 +289,8 @@
 #include "core_cm0plus.h"
 #define ARM_MATH_CM0_FAMILY
 #else
-#include "ARMCM4.h"
-#warning "Define either ARM_MATH_CM4 OR ARM_MATH_CM3...By Default building on ARM_MATH_CM4....."
+#include "core_cm4.h"
+//#warning "Define either ARM_MATH_CM4 OR ARM_MATH_CM3...By Default building on ARM_MATH_CM4....."
 #endif
 
 #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
diff --git a/src/modules/dataman/dataman.h b/src/modules/dataman/dataman.h
index ad8df49..7ea93b8 100644
--- a/src/modules/dataman/dataman.h
+++ b/src/modules/dataman/dataman.h
@@ -39,6 +39,7 @@
 #ifndef _DATAMANAGER_H
 #define _DATAMANAGER_H
 
+#include <navigator/navigation.h>
 #include <uORB/topics/mission.h>
 #include <uORB/topics/fence.h>
 
diff --git a/src/modules/systemlib/cpuload.c b/src/modules/systemlib/cpuload.c
index fe08da7..6d0cea6 100644
--- a/src/modules/systemlib/cpuload.c
+++ b/src/modules/systemlib/cpuload.c
@@ -104,7 +104,7 @@ void cpuload_initialize_once()
 		system_load.tasks[system_load.total_count].valid = true;
 	}
 }
-
+#ifdef HAVE_SCHED_NOTE_START_STOP
 void sched_note_start(FAR struct tcb_s *tcb)
 {
 	/* search first free slot */
@@ -140,7 +140,7 @@ void sched_note_stop(FAR struct tcb_s *tcb)
 		}
 	}
 }
-
+#endif
 void sched_note_switch(FAR struct tcb_s *pFromTcb, FAR struct tcb_s *pToTcb)
 {
 	uint64_t new_time = hrt_absolute_time();
diff --git a/src/modules/systemlib/mcu_version.c b/src/modules/systemlib/mcu_version.c
index 1f66971..1c64d32 100644
--- a/src/modules/systemlib/mcu_version.c
+++ b/src/modules/systemlib/mcu_version.c
@@ -45,7 +45,7 @@
 #include <px4_config.h>
 #include <px4_defines.h>
 
-#ifdef CONFIG_ARCH_CHIP_STM32
+#ifdef CONFIG_ARCH_CHIP_STM32F7
 #include <up_arch.h>
 
 #define DBGMCU_IDCODE	0xE0042000  //STM DocID018909 Rev 8 Sect 38.18 (MCU device ID code)
@@ -59,6 +59,11 @@
 
 #endif
 
+//#ifndef getreg32
+//#define getreg32(a)    (*(volatile uint32_t *)(a))
+//#endif
+
+
 /** Copy the 96bit MCU Unique ID into the provided pointer */
 void mcu_unique_id(uint32_t *uid_96_bit)
 {
diff --git a/src/modules/systemlib/mixer/mixer.h b/src/modules/systemlib/mixer/mixer.h
index cc3342a..5261576 100644
--- a/src/modules/systemlib/mixer/mixer.h
+++ b/src/modules/systemlib/mixer/mixer.h
@@ -427,7 +427,7 @@ public:
 protected:
 
 private:
-	mixer_simple_s			*_info;
+	mixer_simple_s			*try_info;
 
 	static int			parse_output_scaler(const char *buf, unsigned &buflen, mixer_scaler_s &scaler);
 	static int			parse_control_scaler(const char *buf,
diff --git a/src/modules/systemlib/mixer/mixer_simple.cpp b/src/modules/systemlib/mixer/mixer_simple.cpp
index 693f23e..30f5727 100644
--- a/src/modules/systemlib/mixer/mixer_simple.cpp
+++ b/src/modules/systemlib/mixer/mixer_simple.cpp
@@ -56,19 +56,25 @@
 
 #define debug(fmt, args...)	do { } while(0)
 //#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
+/*
+SimpleMixer::SimpleMixer(ControlCallback control_cb, uintptr_t cb_handle, mixer_simple_s *mixinfo):
+	Mixer(control_cb, cb_handle)
+{
+	try_info = mixinfo;
+		
+}
+*/
 
-SimpleMixer::SimpleMixer(ControlCallback control_cb,
-			 uintptr_t cb_handle,
-			 mixer_simple_s *mixinfo) :
+SimpleMixer::SimpleMixer(ControlCallback control_cb, uintptr_t cb_handle, mixer_simple_s *mixinfo):
 	Mixer(control_cb, cb_handle),
-	_info(mixinfo)
+	try_info(mixinfo)
 {
 }
 
 SimpleMixer::~SimpleMixer()
 {
-	if (_info != nullptr)
-		free(_info);
+	if (try_info != nullptr)
+		free(try_info);
 }
 
 int
@@ -269,32 +275,32 @@ SimpleMixer::mix(float *outputs, unsigned space, uint16_t *status_reg)
 {
 	float		sum = 0.0f;
 
-	if (_info == nullptr)
+	if (try_info == nullptr)
 		return 0;
 
 	if (space < 1)
 		return 0;
 
-	for (unsigned i = 0; i < _info->control_count; i++) {
+	for (unsigned i = 0; i < try_info->control_count; i++) {
 		float input;
 
 		_control_cb(_cb_handle,
-			    _info->controls[i].control_group,
-			    _info->controls[i].control_index,
+			    try_info->controls[i].control_group,
+			    try_info->controls[i].control_index,
 			    input);
 
-		sum += scale(_info->controls[i].scaler, input);
+		sum += scale(try_info->controls[i].scaler, input);
 	}
 
-	*outputs = scale(_info->output_scaler, sum);
+	*outputs = scale(try_info->output_scaler, sum);
 	return 1;
 }
 
 void
 SimpleMixer::groups_required(uint32_t &groups)
 {
-	for (unsigned i = 0; i < _info->control_count; i++)
-		groups |= 1 << _info->controls[i].control_group;
+	for (unsigned i = 0; i < try_info->control_count; i++)
+		groups |= 1 << try_info->controls[i].control_group;
 }
 
 int
@@ -305,28 +311,28 @@ SimpleMixer::check()
 
 	/* sanity that presumes that a mixer includes a control no more than once */
 	/* max of 32 groups due to groups_required API */
-	if (_info->control_count > 32)
+	if (try_info->control_count > 32)
 		return -2;
 
 	/* validate the output scaler */
-	ret = scale_check(_info->output_scaler);
+	ret = scale_check(try_info->output_scaler);
 
 	if (ret != 0)
 		return ret;
 
 	/* validate input scalers */
-	for (unsigned i = 0; i < _info->control_count; i++) {
+	for (unsigned i = 0; i < try_info->control_count; i++) {
 
 		/* verify that we can fetch the control */
 		if (_control_cb(_cb_handle,
-				_info->controls[i].control_group,
-				_info->controls[i].control_index,
+				try_info->controls[i].control_group,
+				try_info->controls[i].control_index,
 				junk) != 0) {
 			return -3;
 		}
 
 		/* validate the scaler */
-		ret = scale_check(_info->controls[i].scaler);
+		ret = scale_check(try_info->controls[i].scaler);
 
 		if (ret != 0)
 			return (10 * i + ret);
diff --git a/src/modules/uORB/topics/mission.h b/src/modules/uORB/topics/mission.h
index 22a8f3e..dcd99ff 100644
--- a/src/modules/uORB/topics/mission.h
+++ b/src/modules/uORB/topics/mission.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2012 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,82 +31,36 @@
  *
  ****************************************************************************/
 
-/**
- * @file mission.h
- * Definition of a mission consisting of mission items.
- * @author Thomas Gubler <thomasgubler@student.ethz.ch>
- * @author Julian Oes <joes@student.ethz.ch>
- * @author Lorenz Meier <lm@inf.ethz.ch>
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/mission.msg */
+
 
-#ifndef TOPIC_MISSION_H_
-#define TOPIC_MISSION_H_
+#pragma once
 
 #include <stdint.h>
-#include <stdbool.h>
-#include "../uORB.h"
+#include <uORB/uORB.h>
 
-#define NUM_MISSIONS_SUPPORTED 256
 
-/* compatible to mavlink MAV_CMD */
-enum NAV_CMD {
-	NAV_CMD_IDLE=0,
-	NAV_CMD_WAYPOINT=16,
-	NAV_CMD_LOITER_UNLIMITED=17,
-	NAV_CMD_LOITER_TURN_COUNT=18,
-	NAV_CMD_LOITER_TIME_LIMIT=19,
-	NAV_CMD_RETURN_TO_LAUNCH=20,
-	NAV_CMD_LAND=21,
-	NAV_CMD_TAKEOFF=22,
-	NAV_CMD_ROI=80,
-	NAV_CMD_PATHPLANNING=81,
-	NAV_CMD_DO_JUMP=177
-};
+#ifndef __cplusplus
 
-enum ORIGIN {
-	ORIGIN_MAVLINK = 0,
-	ORIGIN_ONBOARD
-};
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
-/**
- * Global position setpoint in WGS84 coordinates.
- *
- * This is the position the MAV is heading towards. If it of type loiter,
- * the MAV is circling around it with the given loiter radius in meters.
- */
-struct mission_item_s {
-	bool altitude_is_relative;	/**< true if altitude is relative from start point	*/
-	double lat;			/**< latitude in degrees				*/
-	double lon;			/**< longitude in degrees				*/
-	float altitude;			/**< altitude in meters	(AMSL)			*/
-	float yaw;			/**< in radians NED -PI..+PI, NAN means don't change yaw		*/
-	float loiter_radius;		/**< loiter radius in meters, 0 for a VTOL to hover     */
-	int8_t loiter_direction;	/**< 1: positive / clockwise, -1, negative.		*/
-	enum NAV_CMD nav_cmd;		/**< navigation command					*/
-	float acceptance_radius;	/**< default radius in which the mission is accepted as reached in meters */
-	float time_inside;		/**< time that the MAV should stay inside the radius before advancing in seconds */
-	float pitch_min;		/**< minimal pitch angle for fixed wing takeoff waypoints */
-	bool autocontinue;		/**< true if next waypoint should follow after this one */
-	enum ORIGIN origin;		/**< where the waypoint has been generated		*/
-	int do_jump_mission_index;	/**< index where the do jump will go to                 */
-	unsigned do_jump_repeat_count;	/**< how many times do jump needs to be done            */
-	unsigned do_jump_current_count;	/**< count how many times the jump has been done	*/
-};
 
-/**
- * This topic used to notify navigator about mission changes, mission itself and new mission state
- * must be stored in dataman before publication.
- */
-struct mission_s
-{
-	int dataman_id;			/**< default 0, there are two offboard storage places in the dataman: 0 or 1 */
-	unsigned count;			/**< count of the missions stored in the dataman */
-	int current_seq;				/**< default -1, start at the one changed latest */
+#ifdef __cplusplus
+struct __EXPORT mission_s {
+#else
+struct mission_s {
+#endif
+	int32_t dataman_id;
+	uint32_t count;
+	int32_t current_seq;
+#ifdef __cplusplus
+
+#endif
 };
 
 /**
@@ -114,7 +68,4 @@ struct mission_s
  */
 
 /* register this as object request broker structure */
-ORB_DECLARE(offboard_mission);
-ORB_DECLARE(onboard_mission);
-
-#endif
+ORB_DECLARE(mission);
diff --git a/src/modules/uORB/topics/mission_result.h b/src/modules/uORB/topics/mission_result.h
index 16e7f2f..57d3fad 100644
--- a/src/modules/uORB/topics/mission_result.h
+++ b/src/modules/uORB/topics/mission_result.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2012-2014 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,38 +31,46 @@
  *
  ****************************************************************************/
 
-/**
- * @file mission_result.h
- * Mission results that navigator needs to pass on to commander and mavlink.
- *
- * @author Thomas Gubler <thomasgubler@student.ethz.ch>
- * @author Julian Oes <joes@student.ethz.ch>
- * @author Lorenz Meier <lm@inf.ethz.ch>
- * @author Ban Siesta <bansiesta@gmail.com>
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/mission_result.msg */
+
 
-#ifndef TOPIC_MISSION_RESULT_H
-#define TOPIC_MISSION_RESULT_H
+#pragma once
 
 #include <stdint.h>
-#include <stdbool.h>
-#include "../uORB.h"
+#include <uORB/uORB.h>
+
+
+#ifndef __cplusplus
+
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
+
+#ifdef __cplusplus
+struct __EXPORT mission_result_s {
+#else
 struct mission_result_s {
-	unsigned seq_reached;		/**< Sequence of the mission item which has been reached */
-	unsigned seq_current;		/**< Sequence of the current mission item				 */
-	bool reached;			/**< true if mission has been reached					 */
-	bool finished;			/**< true if mission has been completed					 */
-	bool stay_in_failsafe;		/**< true if the commander should not switch out of the failsafe mode*/
-	bool flight_termination;	/**< true if the navigator demands a flight termination from the commander app */
-	bool item_do_jump_changed;	/**< true if the number of do jumps remaining has changed */
-	unsigned item_changed_index;	/**< indicate which item has changed */
-	unsigned item_do_jump_remaining;/**< set to the number of do jumps remaining for that item */
+#endif
+	uint32_t instance_count;
+	uint32_t seq_reached;
+	uint32_t seq_current;
+	bool valid;
+	bool warning;
+	bool reached;
+	bool finished;
+	bool stay_in_failsafe;
+	bool flight_termination;
+	bool item_do_jump_changed;
+	uint32_t item_changed_index;
+	uint32_t item_do_jump_remaining;
+	bool mission_failure;
+#ifdef __cplusplus
+
+#endif
 };
 
 /**
@@ -71,5 +79,3 @@ struct mission_result_s {
 
 /* register this as object request broker structure */
 ORB_DECLARE(mission_result);
-
-#endif
diff --git a/src/modules/uORB/topics/multirotor_motor_limits.h b/src/modules/uORB/topics/multirotor_motor_limits.h
index 589f8a6..a482555 100644
--- a/src/modules/uORB/topics/multirotor_motor_limits.h
+++ b/src/modules/uORB/topics/multirotor_motor_limits.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2012-2013 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,31 +31,37 @@
  *
  ****************************************************************************/
 
-/**
- * @file multirotor_motor_limits.h
- *
- * Definition of multirotor_motor_limits  topic
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/multirotor_motor_limits.msg */
+
 
-#ifndef MULTIROTOR_MOTOR_LIMITS_H_
-#define MULTIROTOR_MOTOR_LIMITS_H_
+#pragma once
 
-#include "../uORB.h"
 #include <stdint.h>
+#include <uORB/uORB.h>
+
+
+#ifndef __cplusplus
+
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
-/**
- * Motor limits
- */
+
+#ifdef __cplusplus
+struct __EXPORT multirotor_motor_limits_s {
+#else
 struct multirotor_motor_limits_s {
-        uint8_t lower_limit	: 1; // at least one actuator command has saturated on the lower limit
-        uint8_t upper_limit	: 1; // at least one actuator command has saturated on the upper limit
-        uint8_t yaw			: 1; // yaw limit reached
-        uint8_t reserved	: 5; // reserved
+#endif
+	uint8_t lower_limit;
+	uint8_t upper_limit;
+	uint8_t yaw;
+	uint8_t reserved;
+#ifdef __cplusplus
+
+#endif
 };
 
 /**
@@ -64,5 +70,3 @@ struct multirotor_motor_limits_s {
 
 /* register this as object request broker structure */
 ORB_DECLARE(multirotor_motor_limits);
-
-#endif
diff --git a/src/modules/uORB/topics/navigation_capabilities.h b/src/modules/uORB/topics/navigation_capabilities.h
index 7a5ae98..3151a47 100644
--- a/src/modules/uORB/topics/navigation_capabilities.h
+++ b/src/modules/uORB/topics/navigation_capabilities.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2012-2013 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,33 +31,39 @@
  *
  ****************************************************************************/
 
-/**
- * @file navigation_capabilities.h
- *
- * Definition of navigation capabilities uORB topic.
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/navigation_capabilities.msg */
 
-#ifndef TOPIC_NAVIGATION_CAPABILITIES_H_
-#define TOPIC_NAVIGATION_CAPABILITIES_H_
 
-#include "../uORB.h"
+#pragma once
+
 #include <stdint.h>
+#include <uORB/uORB.h>
+
+
+#ifndef __cplusplus
+
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
-/**
- * Airspeed
- */
-struct navigation_capabilities_s {
-	float turn_distance;		/**< the optimal distance to a waypoint to switch to the next */
 
-	/* Landing parameters: see fw_pos_control_l1/landingslope.h */
+#ifdef __cplusplus
+struct __EXPORT navigation_capabilities_s {
+#else
+struct navigation_capabilities_s {
+#endif
+	uint64_t timestamp;
+	float turn_distance;
 	float landing_horizontal_slope_displacement;
 	float landing_slope_angle_rad;
 	float landing_flare_length;
+	bool abort_landing;
+#ifdef __cplusplus
+
+#endif
 };
 
 /**
@@ -66,5 +72,3 @@ struct navigation_capabilities_s {
 
 /* register this as object request broker structure */
 ORB_DECLARE(navigation_capabilities);
-
-#endif
diff --git a/src/modules/uORB/topics/rc_parameter_map.h b/src/modules/uORB/topics/rc_parameter_map.h
index 6e68dc4..9b9ba81 100644
--- a/src/modules/uORB/topics/rc_parameter_map.h
+++ b/src/modules/uORB/topics/rc_parameter_map.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2014 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -20,7 +20,7 @@
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT ,
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
@@ -31,46 +31,50 @@
  *
  ****************************************************************************/
 
-/**
- * @file rc_parameter_map.h
- * Maps RC channels to parameters
- *
- * @author Thomas Gubler <thomasgubler@gmail.com>
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/rc_parameter_map.msg */
+
 
-#ifndef TOPIC_RC_PARAMETER_MAP_H
-#define TOPIC_RC_PARAMETER_MAP_H
+#pragma once
 
 #include <stdint.h>
-#include "../uORB.h"
+#include <uORB/uORB.h>
 
-#define RC_PARAM_MAP_NCHAN 3 // This limit is also hardcoded in the enum RC_CHANNELS_FUNCTION in rc_channels.h
-#define PARAM_ID_LEN 16 // corresponds to MAVLINK_MSG_PARAM_VALUE_FIELD_PARAM_ID_LEN
+
+#ifndef __cplusplus
+#define RC_PARAM_MAP_NCHAN 3
+#define PARAM_ID_LEN 16
+
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
-struct rc_parameter_map_s {
-	uint64_t timestamp;			/**< time at which the map was updated */
 
-	bool valid[RC_PARAM_MAP_NCHAN];		/**< true for RC-Param channels which are mapped to a param */
+#ifdef __cplusplus
+struct __EXPORT rc_parameter_map_s {
+#else
+struct rc_parameter_map_s {
+#endif
+	uint64_t timestamp;
+	bool valid[3];
+	int32_t param_index[3];
+	char param_id[51];
+	float scale[3];
+	float value0[3];
+	float value_min[3];
+	float value_max[3];
+#ifdef __cplusplus
+	static const uint8_t RC_PARAM_MAP_NCHAN = 3;
+	static const uint8_t PARAM_ID_LEN = 16;
 
-	int param_index[RC_PARAM_MAP_NCHAN];	/**< corresponding param index, this
-						  this field is ignored if set to -1, in this case param_id will
-						  be used*/
-	char param_id[RC_PARAM_MAP_NCHAN][PARAM_ID_LEN + 1];	/**< corresponding param id, null terminated */
-	float scale[RC_PARAM_MAP_NCHAN];	/** scale to map the RC input [-1, 1] to a parameter value */
-	float value0[RC_PARAM_MAP_NCHAN];	/** inital value around which the parameter value is changed */
-	float value_min[RC_PARAM_MAP_NCHAN];	/** minimal parameter value */
-	float value_max[RC_PARAM_MAP_NCHAN];	/** minimal parameter value */
+#endif
 };
 
 /**
  * @}
  */
 
+/* register this as object request broker structure */
 ORB_DECLARE(rc_parameter_map);
-
-#endif
diff --git a/src/modules/uORB/topics/safety.h b/src/modules/uORB/topics/safety.h
index a5d21cd..3c343f0 100644
--- a/src/modules/uORB/topics/safety.h
+++ b/src/modules/uORB/topics/safety.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2013 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,27 +31,41 @@
  *
  ****************************************************************************/
 
-/**
- * @file safety.h
- *
- * Safety topic to pass safety state from px4io driver to commander
- * This concerns only the safety button of the px4io but has nothing to do
- * with arming/disarming.
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/safety.msg */
+
 
-#ifndef TOPIC_SAFETY_H
-#define TOPIC_SAFETY_H
+#pragma once
 
 #include <stdint.h>
-#include "../uORB.h"
+#include <uORB/uORB.h>
 
+
+#ifndef __cplusplus
+
+#endif
+
+/**
+ * @addtogroup topics
+ * @{
+ */
+
+
+#ifdef __cplusplus
+struct __EXPORT safety_s {
+#else
 struct safety_s {
+#endif
+	uint64_t timestamp;
+	bool safety_switch_available;
+	bool safety_off;
+#ifdef __cplusplus
 
-	uint64_t	timestamp;
-	bool	safety_switch_available;	/**< Set to true if a safety switch is connected */
-	bool	safety_off;			/**< Set to true if safety is off */
+#endif
 };
 
-ORB_DECLARE(safety);
+/**
+ * @}
+ */
 
-#endif
\ No newline at end of file
+/* register this as object request broker structure */
+ORB_DECLARE(safety);
diff --git a/src/modules/uORB/topics/satellite_info.h b/src/modules/uORB/topics/satellite_info.h
index 37c2faa..8a00824 100644
--- a/src/modules/uORB/topics/satellite_info.h
+++ b/src/modules/uORB/topics/satellite_info.h
@@ -1,9 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (C) 2014 PX4 Development Team. All rights reserved.
- *   Author: @author Thomas Gubler <thomasgubler@student.ethz.ch>
- *           @author Julian Oes <joes@student.ethz.ch>
- *           @author Lorenz Meier <lm@inf.ethz.ch>
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -34,50 +31,43 @@
  *
  ****************************************************************************/
 
-/**
- * @file satellite_info.h
- * Definition of the GNSS satellite info uORB topic.
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/satellite_info.msg */
+
 
-#ifndef TOPIC_SAT_INFO_H_
-#define TOPIC_SAT_INFO_H_
+#pragma once
 
 #include <stdint.h>
-#include "../uORB.h"
+#include <uORB/uORB.h>
+
+
+#ifndef __cplusplus
+#define SAT_INFO_MAX_SATELLITES 20
+
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
-/**
- * GNSS Satellite Info.
- */
-
-#define SAT_INFO_MAX_SATELLITES  20
 
+#ifdef __cplusplus
+struct __EXPORT satellite_info_s {
+#else
 struct satellite_info_s {
-	uint64_t timestamp;				/**< Timestamp of satellite info */
-	uint8_t count;					/**< Number of satellites in satellite info */
-	uint8_t svid[SAT_INFO_MAX_SATELLITES]; 		/**< Space vehicle ID [1..255], see scheme below  */
-	uint8_t used[SAT_INFO_MAX_SATELLITES];		/**< 0: Satellite not used, 1: used for navigation */
-	uint8_t elevation[SAT_INFO_MAX_SATELLITES];	/**< Elevation (0: right on top of receiver, 90: on the horizon) of satellite */
-	uint8_t azimuth[SAT_INFO_MAX_SATELLITES];	/**< Direction of satellite, 0: 0 deg, 255: 360 deg. */
-	uint8_t snr[SAT_INFO_MAX_SATELLITES];		/**< dBHz, Signal to noise ratio of satellite C/N0, range 0..99, zero when not tracking this satellite. */
-};
+#endif
+	uint64_t timestamp;
+	uint8_t count;
+	uint8_t svid[20];
+	uint8_t used[20];
+	uint8_t elevation[20];
+	uint8_t azimuth[20];
+	uint8_t snr[20];
+#ifdef __cplusplus
+	static const uint8_t SAT_INFO_MAX_SATELLITES = 20;
 
-/**
- * NAV_SVINFO space vehicle ID (svid) scheme according to u-blox protocol specs
- * u-bloxM8-V15_ReceiverDescriptionProtocolSpec_Public_(UBX-13003221).pdf
- *
- * GPS		1-32
- * SBAS		120-158
- * Galileo	211-246
- * BeiDou	159-163, 33-64
- * QZSS		193-197
- * GLONASS	65-96, 255
- *
- */
+#endif
+};
 
 /**
  * @}
@@ -85,5 +75,3 @@ struct satellite_info_s {
 
 /* register this as object request broker structure */
 ORB_DECLARE(satellite_info);
-
-#endif
diff --git a/src/modules/uORB/topics/telemetry_status.h b/src/modules/uORB/topics/telemetry_status.h
index ee950f4..f92b3bc 100644
--- a/src/modules/uORB/topics/telemetry_status.h
+++ b/src/modules/uORB/topics/telemetry_status.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (c) 2013 PX4 Development Team. All rights reserved.
+ *   Copyright (C) 2013-2015 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,72 +31,61 @@
  *
  ****************************************************************************/
 
-/**
- * @file telemetry_status.h
- *
- * Telemetry status topics - radio status outputs
- */
+/* Auto-generated by genmsg_cpp from file /home/qing/sw/nap/modules/PX4Firmware/msg/telemetry_status.msg */
+
 
-#ifndef TOPIC_TELEMETRY_STATUS_H
-#define TOPIC_TELEMETRY_STATUS_H
+#pragma once
 
 #include <stdint.h>
-#include "../uORB.h"
+#include <uORB/uORB.h>
 
-enum TELEMETRY_STATUS_RADIO_TYPE {
-	TELEMETRY_STATUS_RADIO_TYPE_GENERIC = 0,
-	TELEMETRY_STATUS_RADIO_TYPE_3DR_RADIO,
-	TELEMETRY_STATUS_RADIO_TYPE_UBIQUITY_BULLET,
-	TELEMETRY_STATUS_RADIO_TYPE_WIRE
-};
+
+#ifndef __cplusplus
+#define TELEMETRY_STATUS_RADIO_TYPE_GENERIC 0
+#define TELEMETRY_STATUS_RADIO_TYPE_3DR_RADIO 1
+#define TELEMETRY_STATUS_RADIO_TYPE_UBIQUITY_BULLET 2
+#define TELEMETRY_STATUS_RADIO_TYPE_WIRE 3
+#define TELEMETRY_STATUS_RADIO_TYPE_USB 4
+
+#endif
 
 /**
  * @addtogroup topics
  * @{
  */
 
+
+#ifdef __cplusplus
+struct __EXPORT telemetry_status_s {
+#else
 struct telemetry_status_s {
+#endif
 	uint64_t timestamp;
-	uint64_t heartbeat_time;		/**< Time of last received heartbeat from remote system */
-	uint64_t telem_time;			/**< Time of last received telemetry status packet, 0 for none */
-	enum TELEMETRY_STATUS_RADIO_TYPE type;	/**< type of the radio hardware     */
-	uint8_t rssi;				/**< local signal strength                      */
-	uint8_t remote_rssi;			/**< remote signal strength                     */
-	uint16_t rxerrors;			/**< receive errors                             */
-	uint16_t fixed;				/**< count of error corrected packets           */
-	uint8_t noise;				/**< background noise level                     */
-	uint8_t remote_noise;			/**< remote background noise level              */
-	uint8_t txbuf;				/**< how full the tx buffer is as a percentage  */
-	uint8_t system_id;			/**< system id of the remote system */
-	uint8_t component_id;			/**< component id of the remote system */
+	uint64_t heartbeat_time;
+	uint64_t telem_time;
+	uint8_t type;
+	uint8_t rssi;
+	uint8_t remote_rssi;
+	uint16_t rxerrors;
+	uint16_t fixed;
+	uint8_t noise;
+	uint8_t remote_noise;
+	uint8_t txbuf;
+	uint8_t system_id;
+	uint8_t component_id;
+#ifdef __cplusplus
+	static const uint8_t TELEMETRY_STATUS_RADIO_TYPE_GENERIC = 0;
+	static const uint8_t TELEMETRY_STATUS_RADIO_TYPE_3DR_RADIO = 1;
+	static const uint8_t TELEMETRY_STATUS_RADIO_TYPE_UBIQUITY_BULLET = 2;
+	static const uint8_t TELEMETRY_STATUS_RADIO_TYPE_WIRE = 3;
+	static const uint8_t TELEMETRY_STATUS_RADIO_TYPE_USB = 4;
+
+#endif
 };
 
 /**
  * @}
  */
 
-ORB_DECLARE(telemetry_status_0);
-ORB_DECLARE(telemetry_status_1);
-ORB_DECLARE(telemetry_status_2);
-ORB_DECLARE(telemetry_status_3);
-
-#define TELEMETRY_STATUS_ORB_ID_NUM	4
-
-static const struct orb_metadata *telemetry_status_orb_id[TELEMETRY_STATUS_ORB_ID_NUM] = {
-	ORB_ID(telemetry_status_0),
-	ORB_ID(telemetry_status_1),
-	ORB_ID(telemetry_status_2),
-	ORB_ID(telemetry_status_3),
-};
-
-// This is a hack to quiet an unused-variable warning for when telemetry_status.h is
-// included but telemetry_status_orb_id is not referenced. The inline works if you
-// choose to use it, but you can continue to just directly index into the array as well.
-// If you don't use the inline this ends up being a no-op with no additional code emitted.
-//static const struct orb_metadata *telemetry_status_orb_id_lookup(size_t index);
-static inline const struct orb_metadata *telemetry_status_orb_id_lookup(size_t index)
-{
-	return telemetry_status_orb_id[index];
-}
-
-#endif /* TOPIC_TELEMETRY_STATUS_H */
+/* register this as object request broker structure */
+ORB_DECLARE(telemetry_status);
diff --git a/src/modules/uORB/uORBDevices_nuttx.cpp b/src/modules/uORB/uORBDevices_nuttx.cpp
index d3c30f0..18b7391 100644
--- a/src/modules/uORB/uORBDevices_nuttx.cpp
+++ b/src/modules/uORB/uORBDevices_nuttx.cpp
@@ -165,7 +165,7 @@ uORB::DeviceNode::read(struct file *filp, char *buffer, size_t buflen)
   /*
    * Perform an atomic copy & state update
    */
-  irqstate_t flags = irqsave();
+  irqstate_t flags = up_irq_save();
 
   /* if the caller doesn't want the data, don't give it to them */
   if (nullptr != buffer)
@@ -183,7 +183,7 @@ uORB::DeviceNode::read(struct file *filp, char *buffer, size_t buflen)
    */
   sd->update_reported = false;
 
-  irqrestore(flags);
+  up_irq_restore(flags);
 
   return _meta->o_size;
 }
@@ -222,9 +222,9 @@ uORB::DeviceNode::write(struct file *filp, const char *buffer, size_t buflen)
     return -EIO;
 
   /* Perform an atomic copy. */
-  irqstate_t flags = irqsave();
+  irqstate_t flags = up_irq_save();
   memcpy(_data, buffer, _meta->o_size);
-  irqrestore(flags);
+  up_irq_restore(flags);
 
   /* update the timestamp and generation count */
   _last_update = hrt_absolute_time();
@@ -332,7 +332,7 @@ uORB::DeviceNode::appears_updated(SubscriberData *sd)
   bool ret = false;
 
   /* avoid racing between interrupt and non-interrupt context calls */
-  irqstate_t state = irqsave();
+  irqstate_t state = up_irq_save();
 
   /* check if this topic has been published yet, if not bail out */
   if (_data == nullptr) {
@@ -397,7 +397,7 @@ uORB::DeviceNode::appears_updated(SubscriberData *sd)
   }
 
 out:
-  irqrestore(state);
+  up_irq_restore(state);
 
   /* consider it updated */
   return ret;
diff --git a/src/modules/uavcan/sensors/baro.cpp b/src/modules/uavcan/sensors/baro.cpp
index 9c3a0ae..5792ea4 100644
--- a/src/modules/uavcan/sensors/baro.cpp
+++ b/src/modules/uavcan/sensors/baro.cpp
@@ -112,12 +112,12 @@ int UavcanBarometerBridge::ioctl(struct file *filp, int cmd, unsigned long arg)
 		if ((arg < 1) || (arg > 100))
 			return -EINVAL;
 
-		irqstate_t flags = irqsave();
+		irqstate_t flags = up_irq_save();
 		if (!_reports->resize(arg)) {
-			irqrestore(flags);
+			up_irq_restore(flags);
 			return -ENOMEM;
 		}
-		irqrestore(flags);
+		up_irq_restore(flags);
 
 		return OK;
 	}
diff --git a/src/platforms/nuttx/px4_layer/px4_nuttx_tasks.c b/src/platforms/nuttx/px4_layer/px4_nuttx_tasks.c
index e9b722d..73b909f 100644
--- a/src/platforms/nuttx/px4_layer/px4_nuttx_tasks.c
+++ b/src/platforms/nuttx/px4_layer/px4_nuttx_tasks.c
@@ -61,7 +61,7 @@ void
 px4_systemreset(bool to_bootloader)
 {
 	if (to_bootloader) {
-		stm32_pwr_enablebkp();
+		stm32_pwr_enablebkp(true);
 
 		/* XXX wow, this is evil - write a magic number into backup register zero */
 		*(uint32_t *)0x40002850 = 0xb007b007;
diff --git a/src/platforms/px4_i2c.h b/src/platforms/px4_i2c.h
index 2b72f37..59df117 100644
--- a/src/platforms/px4_i2c.h
+++ b/src/platforms/px4_i2c.h
@@ -38,7 +38,6 @@
  */
 
 #pragma once
-
 #define PX4_I2C_M_READ           0x0001          /* read data, from slave to master */
 
 #if defined(__PX4_ROS)
@@ -53,7 +52,7 @@
 #include <nuttx/arch.h>
 #include <nuttx/wqueue.h>
 #include <nuttx/clock.h>
-#include <nuttx/i2c.h>
+#include <nuttx/i2c/i2c_master.h>
 #include <nuttx/irq.h>
 #include <nuttx/wqueue.h>
 #include <chip.h>
@@ -61,7 +60,6 @@
 #include <arch/chip/chip.h>
 #include "up_internal.h"
 #include "up_arch.h"
-
 #define px4_i2c_msg_t i2c_msg_s
 
 typedef struct i2c_dev_s px4_i2c_dev_t;
diff --git a/src/platforms/px4_spi.h b/src/platforms/px4_spi.h
index 17397ee..2b45179 100644
--- a/src/platforms/px4_spi.h
+++ b/src/platforms/px4_spi.h
@@ -1,7 +1,7 @@
 #pragma once
 
 #ifdef __PX4_NUTTX
-#include <nuttx/spi.h>
+#include <nuttx/spi/spi.h>
 #elif defined(__PX4_POSIX)
 enum spi_dev_e
 {
diff --git a/src/systemcmds/mtd/24xxxx_mtd.c b/src/systemcmds/mtd/24xxxx_mtd.c
index 2aba9db..65aa0d2 100644
--- a/src/systemcmds/mtd/24xxxx_mtd.c
+++ b/src/systemcmds/mtd/24xxxx_mtd.c
@@ -63,8 +63,8 @@
 
 #include <nuttx/kmalloc.h>
 #include <nuttx/fs/ioctl.h>
-#include <nuttx/i2c.h>
-#include <nuttx/mtd.h>
+#include <nuttx/i2c/i2c_master.h>
+#include <nuttx/mtd/mtd.h>
 
 #include "systemlib/perf_counter.h"
 
@@ -146,7 +146,8 @@
 
 struct at24c_dev_s {
 	struct mtd_dev_s      mtd;      /* MTD interface */
-	FAR struct i2c_dev_s *dev;      /* Saved I2C interface instance */
+	//FAR struct i2c_dev_s *dev;      /* Saved I2C interface instance */
+	FAR struct i2c_master_s *dev;      /* Saved I2C interface instance */
 	uint8_t               addr;     /* I2C address */
 	uint16_t              pagesize; /* 32, 63 */
 	uint16_t              npages;   /* 128, 256, 512, 1024 */
@@ -503,7 +504,8 @@ static int at24c_ioctl(FAR struct mtd_dev_s *dev, int cmd, unsigned long arg)
  *
  ************************************************************************************/
 
-FAR struct mtd_dev_s *at24c_initialize(FAR struct i2c_dev_s *dev) {
+//FAR struct mtd_dev_s *at24c_initialize(FAR struct i2c_dev_s *dev) {
+FAR struct mtd_dev_s *at24c_initialize(FAR struct i2c_master_s *dev) {
 	FAR struct at24c_dev_s *priv;
 
 	fvdbg("dev: %p\n", dev);
diff --git a/src/systemcmds/mtd/mtd.c b/src/systemcmds/mtd/mtd.c
index c1dbcad..198e7a1 100644
--- a/src/systemcmds/mtd/mtd.c
+++ b/src/systemcmds/mtd/mtd.c
@@ -51,8 +51,8 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 
-#include <nuttx/spi.h>
-#include <nuttx/mtd.h>
+#include <nuttx/spi/spi.h>
+#include <nuttx/mtd/mtd.h>
 #include <nuttx/fs/nxffs.h>
 #include <nuttx/fs/ioctl.h>
 
diff --git a/src/systemcmds/nshterm/nshterm.c b/src/systemcmds/nshterm/nshterm.c
index 5690815..8c586b9 100644
--- a/src/systemcmds/nshterm/nshterm.c
+++ b/src/systemcmds/nshterm/nshterm.c
@@ -47,7 +47,7 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <errno.h>
-#include <apps/nsh.h>
+#include <apps/nshlib/nshlib.h>
 #include <fcntl.h>
 #include <systemlib/err.h>
 #include <drivers/drv_hrt.h>
diff --git a/src/systemcmds/pwm/pwm.c b/src/systemcmds/pwm/pwm.c
index d6b03eb..2d5d68b 100644
--- a/src/systemcmds/pwm/pwm.c
+++ b/src/systemcmds/pwm/pwm.c
@@ -50,8 +50,8 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 
-#include <nuttx/i2c.h>
-#include <nuttx/mtd.h>
+#include <nuttx/i2c/i2c_master.h>
+#include <nuttx/mtd/mtd.h>
 #include <nuttx/fs/nxffs.h>
 #include <nuttx/fs/ioctl.h>
 
